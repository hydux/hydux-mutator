{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///hydux.collections.js","webpack:///webpack/bootstrap 10c5a48cd516f4b3c1c4","webpack:///./src/collections/map.ts","webpack:///./src/collections/index.ts","webpack:///./src/collections/list.ts","webpack:///../src/index.ts","webpack:///./src/collections/set.ts"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","getType","key","toString","slice","toLowerCase","hash","getTime","map","k","join","objUidMap","uid","objUid","set","objUidKey","hide","obj","prop","height","t","create","left","value","right","Math","max","impossible","Error","balance","leftHeight","rightHeit","add","tree","newKeyHash","rootKeyHash","res","minElt","removeMinElt","internalMerge","remove","keyHash","oldKeyHash","mem","treeKeys","getVal","_i","_a","_b","_c","__generator","_d","label","length","sent","thisArg","body","verb","v","step","op","f","TypeError","_","y","done","ops","pop","trys","push","e","g","next","throw","return","Symbol","iterator","WeakMap","ImmuMap","entries","_tree","_size","added","forEach","callbackfn","has","delete","removed","keys","values","default","list_1","ImmuList","map_1","set_1","ImmuSet","iter","list","item","iteri","len","List","_list","fromArray","empty","toArray","toLocaleString","nth","val","update","_copy","concat","items","arguments","items_1","Array","reduce","append","separator","sep","start","end","newList","indexOf","searchElement","fromIndex","every","_this","some","filter","initialValue","foldl","reduceRight","foldr","find","predicate","findIndex","newImmuList","setEquals","equals","elementEquals","createPath","depth","current","Node","undefined","copyArray","source","array","pushElements","target","offset","amount","copyIndices","sourceStart","targetStart","arrayPrepend","newLength","result","nodePrepend","size","node","sizes","reverseArray","reverse","arrayFirst","arrayLast","updateNode","index","curOffset","branchBits","mask","path","nodeNthDense","nodeNth","cloneNode","suffixToNode","suffix","prefixToNode","prefix","setSizes","sum","sizeTable","sizeOfSubtree","lastSize","affixPush","a","newArray","getSuffixSize","bits","affixMask","getPrefixSize","affixBits","getDepth","setPrefix","setSuffix","setDepth","incrementPrefix","incrementSuffix","incrementDepth","createBits","prefixSize","suffixSize","cloneList","prepend","prependNodeToTree","newPrefix","copyLeft","leafSize","currentNode","i_1","newNode","prependSizes","newSizes","prependTopTree","newOffset","branchingFactor","pow","copyableCount","nodesTraversed","copiedNode","prependDense","parent_1","prependableNode","prepended","newSuffix","suffixNode","appendNodeToTree","elements","elements_1","pair","first","second","emptyAffix","repeat","times","last","mapArray","mapNode","mapAffix","pluck","range","foldlSuffix","acc","foldlPrefix","foldlNode","initial","reject","b","foldrSuffix","foldrPrefix","foldrNode","flatten","nested","foldlSuffixCb","cb","state","foldlPrefixCb","foldlNodeCb","foldlCb","everyCb","someCb","none","findCb","indexOfCb","found","element","findIndexCb","containsCb","includes","containsState","equalsCb","value2","firstList","secondList","equalsState","createConcatPlan","i_2","optimalLength","ceil","eMax","remaining","min","j","concatNodeMerge","center","executeConcatPlan","merged","plan","sourceIdx","plan_1","toMove","available","itemsToCopy","rebalance","top","balanced","concatSubTree","lDepth","rDepth","isTop","getHeight","nodesToCopy","nodesVisited","shift","childIndex","newPath","newRoot","appendEmpty","copyFirstK","oldList","concatAffixes","nr","arrIdx","concatBuffer","newSize","rightSuffixSize","nrOfAffixes","newDepth","adjust","sliceLeft","newAffix","child","sliceRight","sliceTreeList","from","to","pathLeft","pathRight","rec","childLeft","childRight","suffixStart","take","findNotIndexCb","takeWhile","dropWhile","takeLast","splitAt","drop","dropLast","tail","arrayPush","space","ListIterator","iteratorDone","stack","indices","prefixLeft","goUp","idx","incrementIndex","nextInTree","leaf","all","any","contains","init","_map","newSet","v1","v2"],"mappings":"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","file":"hydux.collections.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"collections\"] = factory();\n\telse\n\t\troot[\"hydux\"] = root[\"hydux\"] || {}, root[\"hydux\"][\"collections\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"collections\"] = factory();\n\telse\n\t\troot[\"hydux\"] = root[\"hydux\"] || {}, root[\"hydux\"][\"collections\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar keys = [];\r\nfunction getType(key) {\r\n    var t = Object.prototype.toString.call(key);\r\n    return t.slice(8, -1).toLowerCase();\r\n}\r\nvar objUid = 0;\r\nvar objUidKey = typeof Symbol !== 'undefined' ? Symbol('_hmuid_') : '_hmuid_';\r\nvar objUidMap = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\r\nfunction hash(key) {\r\n    switch (getType(key)) {\r\n        case 'undefined':\r\n        case 'null':\r\n        case 'boolean':\r\n        case 'number':\r\n        case 'regexp':\r\n            return key + '';\r\n        case 'date':\r\n            return '' + key.getTime();\r\n        case 'string':\r\n            return '' + key;\r\n        case 'array':\r\n            return '' + key.map(function (k) { return hash(k); }).join('');\r\n        default:\r\n            if (objUidMap) {\r\n                var uid = objUidMap.get(key);\r\n                if (!uid) {\r\n                    uid = ++objUid;\r\n                    objUidMap.set(key, uid);\r\n                }\r\n                return uid;\r\n            }\r\n            // TODO: Don't use expandos when Object.defineProperty is not available?\r\n            if (!key.hasOwnProperty(objUidKey)) {\r\n                key[objUidKey] = ++objUid;\r\n                hide(key, objUidKey);\r\n            }\r\n            return '' + key[objUidKey];\r\n    }\r\n}\r\nfunction hide(obj, prop) {\r\n    // Make non iterable if supported\r\n    if (Object.defineProperty) {\r\n        Object.defineProperty(obj, prop, { enumerable: false });\r\n    }\r\n}\r\nfunction height(t) {\r\n    if (t) {\r\n        return t.height;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nfunction create(left, value, right) {\r\n    return {\r\n        value: value,\r\n        left: left,\r\n        right: right,\r\n        height: Math.max(height(left), height(right)) + 1,\r\n    };\r\n}\r\nfunction impossible() {\r\n    throw new Error('[hydux-mutator/map] imposible');\r\n}\r\nfunction balance(left, value, right) {\r\n    var leftHeight = height(left);\r\n    var rightHeit = height(right);\r\n    if (leftHeight > rightHeit + 2) {\r\n        if (!left) {\r\n            return impossible();\r\n        }\r\n        else {\r\n            if (height(left.left) >= height(left.right)) {\r\n                return create(left.left, left.value, create(left.right, value, right));\r\n            }\r\n            else if (!left.right) {\r\n                return impossible();\r\n            }\r\n            else {\r\n                return create(create(left.left, left.value, left.right.left), left.right.value, create(left.right.right, value, right));\r\n            }\r\n        }\r\n    }\r\n    else if (rightHeit > leftHeight + 2) {\r\n        if (!right) {\r\n            return impossible();\r\n        }\r\n        else {\r\n            if (height(right.right) >= height(right.right)) {\r\n                return create(create(left, value, right.left), right.value, right.right);\r\n            }\r\n            else if (!right.left) {\r\n                return impossible();\r\n            }\r\n            else {\r\n                return create(create(left, value, right.left.left), right.left.value, create(right.left.right, right.value, right.right));\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return create(left, value, right);\r\n    }\r\n}\r\nfunction add(key, value, tree) {\r\n    if (tree) {\r\n        var newKeyHash = hash(key);\r\n        var rootKeyHash = hash(tree.value[0]);\r\n        if (newKeyHash === rootKeyHash) {\r\n            return [false, tree];\r\n        }\r\n        else if (newKeyHash < rootKeyHash) {\r\n            var res = add(key, value, tree.left);\r\n            return [res[0], balance(res[1], tree.value, tree.right)];\r\n        }\r\n        else {\r\n            var res = add(key, value, tree.right);\r\n            return [res[0], balance(tree.left, tree.value, res[1])];\r\n        }\r\n    }\r\n    else {\r\n        return [true, create(null, [key, value], null)];\r\n    }\r\n}\r\nfunction minElt(value, tree) {\r\n    if (!tree) {\r\n        return value;\r\n    }\r\n    else if (!tree.left) {\r\n        return tree.value;\r\n    }\r\n    else {\r\n        return minElt(tree.value, tree.left);\r\n    }\r\n}\r\nfunction removeMinElt(left, value, right) {\r\n    if (!left) {\r\n        return right;\r\n    }\r\n    else {\r\n        return balance(removeMinElt(left.left, left.value, left.right), value, right);\r\n    }\r\n}\r\nfunction internalMerge(left, right) {\r\n    if (!left) {\r\n        return right;\r\n    }\r\n    else if (!right) {\r\n        return left;\r\n    }\r\n    else if (right) {\r\n        return balance(left, minElt(right.value, right), removeMinElt(right.left, right.value, right.right));\r\n    }\r\n    return impossible();\r\n}\r\nfunction remove(key, tree) {\r\n    if (!tree) {\r\n        return [false, null];\r\n    }\r\n    else {\r\n        var keyHash = hash(key);\r\n        var oldKeyHash = hash(tree.value[0]);\r\n        if (keyHash === oldKeyHash) {\r\n            return [true, internalMerge(tree.left, tree.right)];\r\n        }\r\n        else if (keyHash < oldKeyHash) {\r\n            var res = remove(key, tree.left);\r\n            return [res[0], balance(res[1], tree.value, tree.right)];\r\n        }\r\n        else {\r\n            var res = remove(key, tree.right);\r\n            return [res[0], balance(tree.left, tree.value, res[1])];\r\n        }\r\n    }\r\n}\r\nfunction mem(key, tree) {\r\n    if (!tree) {\r\n        return false;\r\n    }\r\n    var keyHash = hash(key);\r\n    var oldKeyHash = hash(tree.value[0]);\r\n    return keyHash === oldKeyHash || mem(key, (keyHash < oldKeyHash) ? tree.left : tree.right);\r\n}\r\nfunction get(key, tree) {\r\n    if (!tree) {\r\n        return void 0;\r\n    }\r\n    var keyHash = hash(key);\r\n    var oldKeyHash = hash(tree.value[0]);\r\n    if (keyHash === oldKeyHash) {\r\n        return tree.value[1];\r\n    }\r\n    return get(key, (keyHash < oldKeyHash) ? tree.left : tree.right);\r\n}\r\nfunction unimplemented() {\r\n    throw new Error('unimplemented');\r\n}\r\nfunction treeKeys(tree, getVal) {\r\n    var _i, _a, k, _b, _c, k;\r\n    return __generator(this, function (_d) {\r\n        switch (_d.label) {\r\n            case 0:\r\n                if (!tree) {\r\n                    return [2 /*return*/];\r\n                }\r\n                if (!tree.left) return [3 /*break*/, 4];\r\n                _i = 0, _a = treeKeys(tree.left, getVal);\r\n                _d.label = 1;\r\n            case 1:\r\n                if (!(_i < _a.length)) return [3 /*break*/, 4];\r\n                k = _a[_i];\r\n                return [4 /*yield*/, k];\r\n            case 2:\r\n                _d.sent();\r\n                _d.label = 3;\r\n            case 3:\r\n                _i++;\r\n                return [3 /*break*/, 1];\r\n            case 4: return [4 /*yield*/, getVal(tree.value)];\r\n            case 5:\r\n                _d.sent();\r\n                if (!tree.right) return [3 /*break*/, 9];\r\n                _b = 0, _c = treeKeys(tree.right, getVal);\r\n                _d.label = 6;\r\n            case 6:\r\n                if (!(_b < _c.length)) return [3 /*break*/, 9];\r\n                k = _c[_b];\r\n                return [4 /*yield*/, k];\r\n            case 7:\r\n                _d.sent();\r\n                _d.label = 8;\r\n            case 8:\r\n                _b++;\r\n                return [3 /*break*/, 6];\r\n            case 9: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nvar ImmuMap = /** @class */ (function () {\r\n    function ImmuMap(entries) {\r\n        this._tree = null;\r\n        this._size = 0;\r\n        if (entries) {\r\n            for (var _i = 0, _a = entries; _i < _a.length; _i++) {\r\n                var _b = _a[_i], k = _b[0], v = _b[1];\r\n                var _c = add(k, v, this._tree), added = _c[0], tree = _c[1];\r\n                this._tree = tree;\r\n                if (added) {\r\n                    this._size++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(ImmuMap.prototype, \"size\", {\r\n        get: function () {\r\n            return this._size;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ImmuMap.prototype[Symbol.iterator] = function () {\r\n        return this.entries();\r\n    };\r\n    ImmuMap.prototype.forEach = function (callbackfn, thisArg) {\r\n        for (var _i = 0, _a = this.entries(); _i < _a.length; _i++) {\r\n            var _b = _a[_i], key = _b[0], value = _b[1];\r\n            callbackfn.call(thisArg, value, key, this);\r\n        }\r\n    };\r\n    ImmuMap.prototype.get = function (key) {\r\n        return get(key, this._tree);\r\n    };\r\n    ImmuMap.prototype.has = function (key) {\r\n        return mem(key, this._tree);\r\n    };\r\n    ImmuMap.prototype.set = function (key, value) {\r\n        var _a = add(key, value, this._tree), added = _a[0], tree = _a[1];\r\n        if (added) {\r\n            var map = new ImmuMap();\r\n            map._tree = tree;\r\n            map._size++;\r\n            return map;\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    };\r\n    ImmuMap.prototype.delete = function (key) {\r\n        var _a = remove(key, this._tree), removed = _a[0], tree = _a[1];\r\n        if (removed) {\r\n            var map = new ImmuMap();\r\n            map._tree = tree;\r\n            map._size--;\r\n            return map;\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    };\r\n    ImmuMap.prototype.keys = function () {\r\n        return treeKeys(this._tree, function (v) { return v[0]; });\r\n    };\r\n    ImmuMap.prototype.values = function () {\r\n        return treeKeys(this._tree, function (v) { return v[1]; });\r\n    };\r\n    ImmuMap.prototype.entries = function () {\r\n        return treeKeys(this._tree, function (v) { return v; });\r\n    };\r\n    return ImmuMap;\r\n}());\r\nexports.default = ImmuMap;\r\n// let v = null as Tree<number, number>\r\n// const l = Array(10).fill(0).map((_, i) => i)\r\n// l.map(i => v = add(i, i + 1, v))\r\n// function prettyPrint(x) {\r\n//   let opts = { depth: null, colors: 'auto' }\r\n//   // let s = require('util').inspect(x, opts)\r\n//   // console.log (s)\r\n// }\r\n// prettyPrint(v)\r\n// l.map(i => {\r\n//   if (!mem(i, v)) {\r\n//     impossible()\r\n//   }\r\n// })\r\n// l.map(i => {\r\n//   if (get(i, v) !== i + 1) {\r\n//     impossible()\r\n//   }\r\n// })\r\n// for (const key of treeKeys(v, v => v[0])) {\r\n//   console.log('iter key', key)\r\n// }\r\n// l.map(i => {\r\n//   v = remove(i, v)\r\n// })\r\n// prettyPrint(v)\r\n// if (v) {\r\n//   impossible()\r\n// } else {\r\n//   console.log('succuss')\r\n// }\r\n\n\n/***/ }),\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar list_1 = __webpack_require__(6);\r\nexports.ImmuList = list_1.default;\r\nvar map_1 = __webpack_require__(0);\r\nexports.ImmuMap = map_1.default;\r\nvar set_1 = __webpack_require__(8);\r\nexports.ImmuSet = set_1.default;\r\nexports.default = { ImmuList: list_1.default, ImmuMap: map_1.default, ImmuSet: set_1.default };\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar List = __webpack_require__(7);\r\nfunction iter(list, getter) {\r\n    var _i, _a, item;\r\n    return __generator(this, function (_b) {\r\n        switch (_b.label) {\r\n            case 0:\r\n                _i = 0, _a = list;\r\n                _b.label = 1;\r\n            case 1:\r\n                if (!(_i < _a.length)) return [3 /*break*/, 4];\r\n                item = _a[_i];\r\n                return [4 /*yield*/, getter(item)];\r\n            case 2:\r\n                _b.sent();\r\n                _b.label = 3;\r\n            case 3:\r\n                _i++;\r\n                return [3 /*break*/, 1];\r\n            case 4: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nfunction iteri(len) {\r\n    var i;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                i = 0;\r\n                _a.label = 1;\r\n            case 1:\r\n                if (!(i < len)) return [3 /*break*/, 4];\r\n                return [4 /*yield*/, i];\r\n            case 2:\r\n                _a.sent();\r\n                _a.label = 3;\r\n            case 3:\r\n                i++;\r\n                return [3 /*break*/, 1];\r\n            case 4: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nvar ImmuList = /** @class */ (function () {\r\n    function ImmuList(values) {\r\n        if (values) {\r\n            this._list = List.fromArray(values);\r\n        }\r\n        else {\r\n            this._list = List.empty();\r\n        }\r\n    }\r\n    Object.defineProperty(ImmuList.prototype, \"length\", {\r\n        get: function () {\r\n            return this._list.length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ImmuList.prototype.toString = function () {\r\n        return List.toArray(this._list).toString();\r\n    };\r\n    ImmuList.prototype.toLocaleString = function () {\r\n        return List.toArray(this._list).toLocaleString();\r\n    };\r\n    ImmuList.prototype.get = function (i) {\r\n        return List.nth(i, this._list);\r\n    };\r\n    ImmuList.prototype.set = function (i, val) {\r\n        var list = List.update(i, val, this._list);\r\n        return this._copy(list);\r\n    };\r\n    ImmuList.prototype.concat = function () {\r\n        var items = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            items[_i] = arguments[_i];\r\n        }\r\n        var list = this._list;\r\n        for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {\r\n            var item = items_1[_a];\r\n            if (item instanceof ImmuList) {\r\n                list = List.concat(list, item._list);\r\n            }\r\n            else if (item instanceof Array) {\r\n                list = item.reduce(function (l, i) { return List.append(i, l); }, list);\r\n            }\r\n            else {\r\n                list = List.append(item, list);\r\n            }\r\n        }\r\n        if (list.length > this._list.length) {\r\n            return this._copy(list);\r\n        }\r\n        return this;\r\n    };\r\n    ImmuList.prototype.join = function (separator) {\r\n        var sep = separator || ',';\r\n        return List.join(sep, this._list);\r\n    };\r\n    ImmuList.prototype.slice = function (start, end) {\r\n        var newList = List.slice(start || 0, end || this._list.length, this._list);\r\n        if (newList.length !== this._list.length) {\r\n            return this._copy(newList);\r\n        }\r\n        return this;\r\n    };\r\n    ImmuList.prototype.indexOf = function (searchElement, fromIndex) {\r\n        var list = this._list;\r\n        if (fromIndex) {\r\n            list = List.slice(fromIndex, this._list.length, list);\r\n        }\r\n        return List.indexOf(searchElement, list);\r\n    };\r\n    ImmuList.prototype.every = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.every(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n    };\r\n    ImmuList.prototype.some = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.some(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n    };\r\n    ImmuList.prototype.forEach = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        List.every(function (v) {\r\n            callbackfn.call(thisArg, v, i++, _this);\r\n            return true;\r\n        }, this._list);\r\n    };\r\n    ImmuList.prototype.map = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        var list = List.map(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n        return this._copy(list);\r\n    };\r\n    ImmuList.prototype.filter = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        var list = List.filter(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n        if (list.length !== this._list.length) {\r\n            return this._copy(list);\r\n        }\r\n        return this;\r\n    };\r\n    ImmuList.prototype.reduce = function (callbackfn, initialValue, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.foldl(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, initialValue, this._list);\r\n    };\r\n    ImmuList.prototype.reduceRight = function (callbackfn, initialValue, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.foldr(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, initialValue, this._list);\r\n    };\r\n    ImmuList.prototype[Symbol.iterator] = function () {\r\n        return iter(this._list, function (v) { return v; });\r\n    };\r\n    ImmuList.prototype.entries = function () {\r\n        var i = 0;\r\n        return iter(this._list, function (v) { return [i++, v]; });\r\n    };\r\n    ImmuList.prototype.keys = function () {\r\n        return iteri(this._list.length);\r\n    };\r\n    ImmuList.prototype.values = function () {\r\n        return iter(this._list, function (v) { return v; });\r\n    };\r\n    ImmuList.prototype.find = function (predicate, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.find(function (v) {\r\n            return predicate.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n    };\r\n    ImmuList.prototype.findIndex = function (predicate, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.findIndex(function (v) {\r\n            return predicate.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n    };\r\n    ImmuList.prototype._copy = function (list) {\r\n        var newImmuList = new ImmuList();\r\n        newImmuList._list = list;\r\n        return newImmuList;\r\n    };\r\n    return ImmuList;\r\n}());\r\nexports.default = ImmuList;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar branchingFactor = 32;\nvar branchBits = 5;\nvar mask = 31;\nvar elementEquals = function (a, b) {\n    return a === b;\n};\nfunction setEquals(equals) {\n    elementEquals = equals;\n}\nexports.setEquals = setEquals;\nfunction createPath(depth, value) {\n    var current = value;\n    for (var i = 0; i < depth; ++i) {\n        current = new Node(undefined, [current]);\n    }\n    return current;\n}\n// Array helper functions\nfunction copyArray(source) {\n    var array = [];\n    for (var i = 0; i < source.length; ++i) {\n        array[i] = source[i];\n    }\n    return array;\n}\nfunction pushElements(source, target, offset, amount) {\n    for (var i = offset; i < offset + amount; ++i) {\n        target.push(source[i]);\n    }\n}\nfunction copyIndices(source, sourceStart, target, targetStart, length) {\n    for (var i = 0; i < length; ++i) {\n        target[targetStart + i] = source[sourceStart + i];\n    }\n}\nfunction arrayPrepend(value, array) {\n    var newLength = array.length + 1;\n    var result = new Array(newLength);\n    result[0] = value;\n    for (var i = 1; i < newLength; ++i) {\n        result[i] = array[i - 1];\n    }\n    return result;\n}\n/**\n * Prepends an element to a node\n */\nfunction nodePrepend(value, size, node) {\n    var array = arrayPrepend(value, node.array);\n    var sizes = undefined;\n    if (node.sizes !== undefined) {\n        sizes = new Array(node.sizes.length + 1);\n        sizes[0] = size;\n        for (var i = 0; i < node.sizes.length; ++i) {\n            sizes[i + 1] = node.sizes[i] + size;\n        }\n    }\n    return new Node(sizes, array);\n}\n/**\n * Create a reverse _copy_ of an array.\n */\nfunction reverseArray(array) {\n    return array.slice().reverse();\n}\nfunction arrayFirst(array) {\n    return array[0];\n}\nfunction arrayLast(array) {\n    return array[array.length - 1];\n}\nfunction updateNode(node, depth, index, offset, value) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    if (node.sizes !== undefined) {\n        while (node.sizes[path] <= index) {\n            path++;\n        }\n        var traversed = path === 0 ? 0 : node.sizes[path - 1];\n        index -= traversed;\n    }\n    var array;\n    if (path < 0) {\n        // TOOD: Once `prepend` no longer uses `update` this should be removed\n        array = arrayPrepend(createPath(depth, value), node.array);\n    }\n    else {\n        array = copyArray(node.array);\n        if (depth === 0) {\n            array[path] = value;\n        }\n        else {\n            array[path] = updateNode(array[path], depth - 1, index, path === 0 ? offset : 0, value);\n        }\n    }\n    return new Node(node.sizes, array);\n}\nvar Node = /** @class */ (function () {\n    function Node(sizes, array) {\n        this.sizes = sizes;\n        this.array = array;\n    }\n    return Node;\n}());\nexports.Node = Node;\nfunction nodeNthDense(node, depth, index, offset) {\n    index += offset;\n    var path;\n    var current = node;\n    for (; depth >= 0; --depth) {\n        path =\n            ((index >> (depth * branchBits)) & mask) -\n                ((offset >> (depth * branchBits)) & mask);\n        if (path !== 0) {\n            offset = 0;\n        }\n        current = current.array[path];\n    }\n    return current;\n}\nfunction nodeNth(node, depth, index) {\n    var path;\n    var current = node;\n    while (current.sizes !== undefined) {\n        path = (index >> (depth * branchBits)) & mask;\n        while (current.sizes[path] <= index) {\n            path++;\n        }\n        var traversed = path === 0 ? 0 : current.sizes[path - 1];\n        index -= traversed;\n        depth--;\n        current = current.array[path];\n    }\n    return nodeNthDense(current, depth, index, 0);\n}\nfunction cloneNode(_a) {\n    var sizes = _a.sizes, array = _a.array;\n    return new Node(sizes === undefined ? undefined : copyArray(sizes), copyArray(array));\n}\nfunction suffixToNode(suffix) {\n    // FIXME: should take size and copy\n    return new Node(undefined, suffix);\n}\nfunction prefixToNode(prefix) {\n    // FIXME: should take size and copy\n    return new Node(undefined, prefix.reverse());\n}\nfunction setSizes(node, height) {\n    var sum = 0;\n    var sizeTable = [];\n    for (var i = 0; i < node.array.length; ++i) {\n        sum += sizeOfSubtree(node.array[i], height - 1);\n        sizeTable[i] = sum;\n    }\n    node.sizes = sizeTable;\n    return node;\n}\n/**\n * Returns the number of elements stored in the node.\n */\nfunction sizeOfSubtree(node, height) {\n    if (height !== 0) {\n        if (node.sizes !== undefined) {\n            return arrayLast(node.sizes);\n        }\n        else {\n            // the node is leftwise dense so all all but the last child are full\n            var lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);\n            return ((node.array.length - 1) << (height * branchBits)) + lastSize;\n        }\n    }\n    else {\n        return node.array.length;\n    }\n}\n// This array should not be mutated. Thus a dummy element is placed in\n// it. Thus the affix will not be owned and thus not mutated.\nvar emptyAffix = [0];\nfunction affixPush(a, array, length) {\n    if (array.length === length) {\n        array.push(a);\n        return array;\n    }\n    else {\n        var newArray = [];\n        copyIndices(array, 0, newArray, 0, length);\n        newArray.push(a);\n        return newArray;\n    }\n}\n// We store a bit field in list. From right to left, the first five\n// bits are suffix length, the next five are prefix length and the\n// rest is depth. The functions below are for working with the bits in\n// a sane way.\nvar affixBits = 6;\nvar affixMask = 63;\nfunction getSuffixSize(l) {\n    return l.bits & affixMask;\n}\nfunction getPrefixSize(l) {\n    return (l.bits >> affixBits) & affixMask;\n}\nfunction getDepth(l) {\n    return l.bits >> (affixBits * 2);\n}\nfunction setPrefix(size, bits) {\n    return (size << affixBits) | (bits & ~(affixMask << affixBits));\n}\nfunction setSuffix(size, bits) {\n    return size | (bits & ~affixMask);\n}\nfunction setDepth(depth, bits) {\n    return ((depth << (affixBits * 2)) | (bits & (affixMask | (affixMask << affixBits))));\n}\nfunction incrementPrefix(bits) {\n    return bits + (1 << affixBits);\n}\nfunction incrementSuffix(bits) {\n    return bits + 1;\n}\nfunction incrementDepth(bits) {\n    return bits + (1 << (affixBits * 2));\n}\n// function decrementDepth(bits: number): number {\n//   return bits - (1 << (affixBits * 2));\n// }\nfunction createBits(depth, prefixSize, suffixSize) {\n    return (depth << (affixBits * 2)) | (prefixSize << affixBits) | suffixSize;\n}\n/*\n * Invariants that any list `l` should satisfy\n *\n * 1. If `l.root !== undefined` then `getSuffixSize(l) !== 0` and\n *   `getPrefixSize(l) !== 0`. The invariant ensures that `first` and\n *   `last` never have to look in the root and that they therefore\n *   take O(1) time.\n * 2. If a tree or sub-tree does not have a size-table then all leaf\n      nodes in the tree are of size 32.\n */\nvar List = /** @class */ (function () {\n    function List(bits, offset, length, root, suffix, prefix) {\n        this.bits = bits;\n        this.offset = offset;\n        this.length = length;\n        this.root = root;\n        this.suffix = suffix;\n        this.prefix = prefix;\n    }\n    List.prototype.space = function () {\n        return (Math.pow(branchingFactor, (getDepth(this) + 1)) -\n            (this.length - getSuffixSize(this) - getPrefixSize(this) + this.offset));\n    };\n    List.prototype[Symbol.iterator] = function () {\n        return new ListIterator(this);\n    };\n    List.prototype[\"fantasy-land/equals\"] = function (l) {\n        return equals(this, l);\n    };\n    List.prototype[\"fantasy-land/map\"] = function (f) {\n        return map(f, this);\n    };\n    List.prototype[\"fantasy-land/filter\"] = function (predicate) {\n        return filter(predicate, this);\n    };\n    List.prototype[\"fantasy-land/empty\"] = function () {\n        return empty();\n    };\n    List.prototype[\"fantasy-land/concat\"] = function (right) {\n        return concat(this, right);\n    };\n    List.prototype[\"fantasy-land/reduce\"] = function (f, initial) {\n        return foldl(f, initial, this);\n    };\n    List.prototype.append = function (value) {\n        return append(value, this);\n    };\n    List.prototype.nth = function (index) {\n        return nth(index, this);\n    };\n    return List;\n}());\nexports.List = List;\nfunction cloneList(l) {\n    return new List(l.bits, l.offset, l.length, l.root, l.suffix, l.prefix);\n}\nvar iteratorDone = { done: true, value: undefined };\nvar ListIterator = /** @class */ (function () {\n    function ListIterator(list) {\n        this.list = list;\n        this.stack = [];\n        this.indices = [];\n        this.prefixLeft = getPrefixSize(list);\n        if (list.root !== undefined) {\n            var currentNode = list.root.array;\n            var depth = getDepth(list);\n            for (var i = 0; i < depth + 1; ++i) {\n                this.stack.push(currentNode);\n                this.indices.push(0);\n                currentNode = arrayFirst(currentNode).array;\n            }\n            this.indices[this.indices.length - 1] = -1;\n        }\n        else {\n            this.indices.push(-1);\n        }\n    }\n    ListIterator.prototype.goUp = function () {\n        this.stack.pop();\n        this.indices.pop();\n    };\n    ListIterator.prototype.remaining = function () {\n        var node = arrayLast(this.stack);\n        var idx = arrayLast(this.indices);\n        return node.length - idx - 1;\n    };\n    ListIterator.prototype.incrementIndex = function () {\n        return ++this.indices[this.indices.length - 1];\n    };\n    ListIterator.prototype.nextInTree = function () {\n        while (this.remaining() === 0) {\n            this.goUp();\n            if (this.stack.length === 0) {\n                return;\n            }\n        }\n        this.incrementIndex();\n        var depth = getDepth(this.list);\n        for (var i = this.indices.length - 1; i < depth; ++i) {\n            this.stack.push(arrayLast(this.stack)[arrayLast(this.indices)].array);\n            this.indices.push(0);\n        }\n    };\n    ListIterator.prototype.next = function () {\n        if (this.prefixLeft > 0) {\n            --this.prefixLeft;\n            return { done: false, value: this.list.prefix[this.prefixLeft] };\n        }\n        else if (this.stack.length !== 0) {\n            this.nextInTree();\n            if (this.stack.length !== 0) {\n                var leaf = arrayLast(this.stack);\n                var idx = arrayLast(this.indices);\n                var value = leaf[idx];\n                return { done: false, value: value };\n            }\n            else {\n                this.indices.push(-1);\n            }\n        }\n        var suffixSize = getSuffixSize(this.list);\n        if (this.indices[0] < suffixSize - 1) {\n            var idx = this.incrementIndex();\n            return { done: false, value: this.list.suffix[idx] };\n        }\n        return iteratorDone;\n    };\n    return ListIterator;\n}());\n// prepend & append\nfunction prepend(value, l) {\n    var prefixSize = getPrefixSize(l);\n    if (prefixSize < 32) {\n        return new List(incrementPrefix(l.bits), l.offset, l.length + 1, l.root, l.suffix, affixPush(value, l.prefix, prefixSize));\n    }\n    else {\n        var newList = cloneList(l);\n        prependNodeToTree(newList, reverseArray(l.prefix));\n        var newPrefix = [value];\n        newList.prefix = newPrefix;\n        newList.length++;\n        newList.bits = setPrefix(1, newList.bits);\n        return newList;\n    }\n}\nexports.prepend = prepend;\n/**\n * Traverses down the left edge of the tree and copies k nodes.\n * Returns the last copied node.\n * @param l\n * @param k The number of nodes to copy. Will always be at least 1.\n * @param leafSize The number of elements in the leaf that will be\n * inserted.\n */\nfunction copyLeft(l, k, leafSize) {\n    var currentNode = cloneNode(l.root); // copy root\n    l.root = currentNode; // install copy of root\n    for (var i = 1; i < k; ++i) {\n        var index = 0; // go left\n        if (currentNode.sizes !== undefined) {\n            for (var i_1 = 0; i_1 < currentNode.sizes.length; ++i_1) {\n                currentNode.sizes[i_1] += leafSize;\n            }\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        // Install the copied node\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    return currentNode;\n}\nfunction prependSizes(n, sizes) {\n    if (sizes === undefined) {\n        return undefined;\n    }\n    else {\n        var newSizes = new Array(sizes.length + 1);\n        newSizes[0] = n;\n        for (var i = 0; i < sizes.length; ++i) {\n            newSizes[i + 1] = sizes[i] + n;\n        }\n        return newSizes;\n    }\n}\n/**\n * Prepends a node to a tree. Either by shifting the nodes in the root\n * left or by increasing the height\n */\nfunction prependTopTree(l, depth, node) {\n    var newOffset;\n    if (l.root.array.length < branchingFactor) {\n        // There is space in the root\n        newOffset = Math.pow(32, depth) - 32;\n        l.root = new Node(prependSizes(32, l.root.sizes), arrayPrepend(createPath(depth - 1, node), l.root.array));\n    }\n    else {\n        // We need to create a new root\n        l.bits = incrementDepth(l.bits);\n        var sizes = l.root.sizes === undefined\n            ? undefined\n            : [32, arrayLast(l.root.sizes) + 32];\n        newOffset = depth === 0 ? 0 : Math.pow(32, (depth + 1)) - 32;\n        l.root = new Node(sizes, [createPath(depth, node), l.root]);\n    }\n    return newOffset;\n}\n/**\n * Takes a RRB-tree and a node tail. It then prepends the node to the\n * tree.\n * @param l The subject for prepending. `l` will be mutated. Nodes in\n * the tree will _not_ be mutated.\n * @param node The node that should be prepended to the tree.\n */\nfunction prependNodeToTree(l, array) {\n    if (l.root === undefined) {\n        if (getSuffixSize(l) === 0) {\n            // ensure invariant 1\n            l.bits = setSuffix(array.length, l.bits);\n            l.suffix = array;\n        }\n        else {\n            l.root = new Node(undefined, array);\n        }\n        return l;\n    }\n    else {\n        var node = new Node(undefined, array);\n        var depth = getDepth(l);\n        var newOffset = 0;\n        if (l.root.sizes === undefined) {\n            if (l.offset !== 0) {\n                newOffset = l.offset - branchingFactor;\n                l.root = prependDense(l.root, depth - 1, (l.offset - 1) >> 5, l.offset >> 5, node);\n            }\n            else {\n                // in this case we can be sure that the is not room in the tree\n                // for the new node\n                newOffset = prependTopTree(l, depth, node);\n            }\n        }\n        else {\n            // represents how many nodes _with size-tables_ that we should copy.\n            var copyableCount = 0;\n            // go down while there is size tables\n            var nodesTraversed = 0;\n            var currentNode = l.root;\n            while (currentNode.sizes !== undefined && nodesTraversed < depth) {\n                ++nodesTraversed;\n                if (currentNode.array.length < 32) {\n                    // there is room if offset is > 0 or if the first node does not\n                    // contain as many nodes as it possibly can\n                    copyableCount = nodesTraversed;\n                }\n                currentNode = currentNode.array[0];\n            }\n            if (l.offset !== 0) {\n                var copiedNode = copyLeft(l, nodesTraversed, 32);\n                for (var i = 0; i < copiedNode.sizes.length; ++i) {\n                    copiedNode.sizes[i] += branchingFactor;\n                }\n                copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed - 1, (l.offset - 1) >> 5, l.offset >> 5, node);\n                l.offset = l.offset - branchingFactor;\n                return l;\n            }\n            else {\n                if (copyableCount === 0) {\n                    l.offset = prependTopTree(l, depth, node);\n                }\n                else {\n                    var parent_1;\n                    var prependableNode = void 0;\n                    // Copy the part of the path with size tables\n                    if (copyableCount > 1) {\n                        parent_1 = copyLeft(l, copyableCount - 1, 32);\n                        prependableNode = parent_1.array[0];\n                    }\n                    else {\n                        parent_1 = undefined;\n                        prependableNode = l.root;\n                    }\n                    var path = createPath(depth - copyableCount, node);\n                    // add offset\n                    l.offset = Math.pow(32, (depth - copyableCount + 1)) - 32;\n                    var prepended = nodePrepend(path, 32, prependableNode);\n                    if (parent_1 === undefined) {\n                        l.root = prepended;\n                    }\n                    else {\n                        parent_1.array[0] = prepended;\n                    }\n                }\n                return l;\n            }\n        }\n        l.offset = newOffset;\n        return l;\n    }\n}\nfunction prependDense(node, depth, index, offset, value) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    var array;\n    if (path < 0) {\n        array = arrayPrepend(createPath(depth, value), node.array);\n    }\n    else {\n        array = copyArray(node.array);\n        if (depth === 0) {\n            array[path] = value;\n        }\n        else {\n            array[path] = updateNode(array[path], depth - 1, index, path === 0 ? offset : 0, value);\n        }\n    }\n    return new Node(node.sizes, array);\n}\nfunction append(value, l) {\n    var suffixSize = getSuffixSize(l);\n    if (suffixSize < 32) {\n        return new List(incrementSuffix(l.bits), l.offset, l.length + 1, l.root, affixPush(value, l.suffix, suffixSize), l.prefix);\n    }\n    var newSuffix = [value];\n    var suffixNode = suffixToNode(l.suffix);\n    var newList = cloneList(l);\n    appendNodeToTree(newList, suffixNode);\n    newList.suffix = newSuffix;\n    newList.length++;\n    newList.bits = setSuffix(1, newList.bits);\n    return newList;\n}\nexports.append = append;\nfunction list() {\n    var elements = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        elements[_i] = arguments[_i];\n    }\n    var l = empty();\n    for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {\n        var element = elements_1[_a];\n        l = append(element, l);\n    }\n    return l;\n}\nexports.list = list;\nfunction pair(first, second) {\n    return new List(2, 0, 2, undefined, [first, second], emptyAffix);\n}\nexports.pair = pair;\nfunction empty() {\n    return new List(0, 0, 0, undefined, emptyAffix, emptyAffix);\n}\nexports.empty = empty;\nfunction repeat(value, times) {\n    var l = empty();\n    while (--times >= 0) {\n        l = append(value, l);\n    }\n    return l;\n}\nexports.repeat = repeat;\nfunction length(l) {\n    return l.length;\n}\nexports.length = length;\nfunction first(l) {\n    if (getPrefixSize(l) !== 0) {\n        return arrayLast(l.prefix);\n    }\n    else if (getSuffixSize(l) !== 0) {\n        return arrayFirst(l.suffix);\n    }\n}\nexports.first = first;\nfunction last(l) {\n    if (getSuffixSize(l) !== 0) {\n        return arrayLast(l.suffix);\n    }\n    else if (getPrefixSize(l) !== 0) {\n        return arrayFirst(l.prefix);\n    }\n}\nexports.last = last;\nfunction nth(index, l) {\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    var offset = l.offset;\n    if (index < prefixSize) {\n        return l.prefix[prefixSize - index - 1];\n    }\n    else if (index >= l.length - suffixSize) {\n        return l.suffix[index - (l.length - suffixSize)];\n    }\n    var depth = getDepth(l);\n    return l.root.sizes === undefined\n        ? nodeNthDense(l.root, depth, index - prefixSize, offset)\n        : nodeNth(l.root, depth, index - prefixSize);\n}\nexports.nth = nth;\n// map\nfunction mapArray(f, array) {\n    var result = new Array(array.length);\n    for (var i = 0; i < array.length; ++i) {\n        result[i] = f(array[i]);\n    }\n    return result;\n}\nfunction mapNode(f, node, depth) {\n    if (depth !== 0) {\n        var array = node.array;\n        var result = new Array(array.length);\n        for (var i = 0; i < array.length; ++i) {\n            result[i] = mapNode(f, array[i], depth - 1);\n        }\n        return new Node(node.sizes, result);\n    }\n    else {\n        return new Node(undefined, mapArray(f, node.array));\n    }\n}\nfunction mapAffix(f, suffix, length) {\n    var newSuffix = new Array(length);\n    for (var i = 0; i < length; ++i) {\n        newSuffix[i] = f(suffix[i]);\n    }\n    return newSuffix;\n}\nfunction map(f, l) {\n    return new List(l.bits, l.offset, l.length, l.root === undefined ? undefined : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)), mapAffix(f, l.prefix, getPrefixSize(l)));\n}\nexports.map = map;\nfunction pluck(key, l) {\n    return map(function (a) { return a[key]; }, l);\n}\nexports.pluck = pluck;\nfunction range(start, end) {\n    var list = empty();\n    for (var i = start; i < end; ++i) {\n        list = list.append(i);\n    }\n    return list;\n}\nexports.range = range;\n// fold\nfunction foldlSuffix(f, acc, array, length) {\n    for (var i = 0; i < length; ++i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlPrefix(f, acc, array, length) {\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlNode(f, acc, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlSuffix(f, acc, array, array.length);\n    }\n    for (var i = 0; i < array.length; ++i) {\n        acc = foldlNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nfunction foldl(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    initial = foldlPrefix(f, initial, l.prefix, prefixSize);\n    if (l.root !== undefined) {\n        initial = foldlNode(f, initial, l.root, getDepth(l));\n    }\n    return foldlSuffix(f, initial, l.suffix, suffixSize);\n}\nexports.foldl = foldl;\nexports.reduce = foldl;\nfunction filter(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? append(a, acc) : acc); }, empty(), l);\n}\nexports.filter = filter;\nfunction reject(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? acc : append(a, acc)); }, empty(), l);\n}\nexports.reject = reject;\nfunction join(separator, l) {\n    return foldl(function (a, b) { return (a.length === 0 ? b : a + separator + b); }, \"\", l);\n}\nexports.join = join;\nfunction foldrSuffix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrPrefix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = 0; i < length; ++i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrNode(f, initial, _a, depth) {\n    var array = _a.array;\n    if (depth === 0) {\n        return foldrSuffix(f, initial, array, array.length);\n    }\n    var acc = initial;\n    for (var i = array.length - 1; 0 <= i; --i) {\n        acc = foldrNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nfunction foldr(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    var acc = foldrSuffix(f, initial, l.suffix, suffixSize);\n    if (l.root !== undefined) {\n        acc = foldrNode(f, acc, l.root, getDepth(l));\n    }\n    return foldrPrefix(f, acc, l.prefix, prefixSize);\n}\nexports.foldr = foldr;\nexports.reduceRight = foldr;\nfunction flatten(nested) {\n    return foldl(concat, empty(), nested);\n}\nexports.flatten = flatten;\nfunction foldlSuffixCb(cb, state, array, length) {\n    for (var i = 0; i < length && cb(array[i], state); ++i) { }\n    return i === length;\n}\nfunction foldlPrefixCb(cb, state, array, length) {\n    for (var i = length - 1; 0 <= i && cb(array[i], state); --i) { }\n    return i === -1;\n}\nfunction foldlNodeCb(cb, state, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlSuffixCb(cb, state, array, array.length);\n    }\n    for (var i = 0; i < array.length && foldlNodeCb(cb, state, array[i], depth - 1); ++i) { }\n    return i === array.length;\n}\n/**\n * This function is a lot like a fold. But the reducer function is\n * supposed to mutate its state instead of returning it. Instead of\n * returning a new state it returns a boolean that tells wether or not\n * to continue the fold. `true` indicates that the folding should\n * continue.\n */\nfunction foldlCb(cb, state, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    if (foldlPrefixCb(cb, state, l.prefix, prefixSize)) {\n        if (l.root !== undefined) {\n            if (foldlNodeCb(cb, state, l.root, getDepth(l))) {\n                foldlSuffixCb(cb, state, l.suffix, suffixSize);\n            }\n        }\n        else {\n            foldlSuffixCb(cb, state, l.suffix, suffixSize);\n        }\n    }\n    return state;\n}\nfunction everyCb(value, state) {\n    return (state.result = state.predicate(value));\n}\nfunction every(predicate, l) {\n    return foldlCb(everyCb, { predicate: predicate, result: true }, l).result;\n}\nexports.every = every;\nexports.all = every;\nfunction someCb(value, state) {\n    return !(state.result = state.predicate(value));\n}\nfunction some(predicate, l) {\n    return foldlCb(someCb, { predicate: predicate, result: false }, l).result;\n}\nexports.some = some;\n// tslint:disable-next-line:variable-name\nexports.any = some;\nfunction none(predicate, l) {\n    return !some(predicate, l);\n}\nexports.none = none;\nfunction findCb(value, state) {\n    if (state.predicate(value)) {\n        state.result = value;\n        return false;\n    }\n    else {\n        return true;\n    }\n}\nfunction find(predicate, l) {\n    return foldlCb(findCb, { predicate: predicate, result: undefined }, l)\n        .result;\n}\nexports.find = find;\nfunction indexOfCb(value, state) {\n    ++state.index;\n    return !(state.found = elementEquals(value, state.element));\n}\nfunction indexOf(element, l) {\n    var _a = foldlCb(indexOfCb, { element: element, found: false, index: -1 }, l), found = _a.found, index = _a.index;\n    return found ? index : -1;\n}\nexports.indexOf = indexOf;\nfunction findIndexCb(value, state) {\n    ++state.index;\n    return !(state.found = state.predicate(value));\n}\nfunction findIndex(predicate, l) {\n    var _a = foldlCb(findIndexCb, { predicate: predicate, found: false, index: -1 }, l), found = _a.found, index = _a.index;\n    return found ? index : -1;\n}\nexports.findIndex = findIndex;\nvar containsState = {\n    element: undefined,\n    result: false\n};\nfunction containsCb(value, state) {\n    return !(state.result = value === state.element);\n}\nfunction includes(element, l) {\n    containsState.element = element;\n    containsState.result = false;\n    return foldlCb(containsCb, containsState, l).result;\n}\nexports.includes = includes;\nexports.contains = includes;\nvar equalsState = {\n    iterator: undefined,\n    equals: true\n};\nfunction equalsCb(value2, state) {\n    var value = state.iterator.next().value;\n    return (state.equals = elementEquals(value, value2));\n}\nfunction equals(firstList, secondList) {\n    if (firstList === secondList) {\n        return true;\n    }\n    else if (firstList.length !== secondList.length) {\n        return false;\n    }\n    else {\n        equalsState.iterator = secondList[Symbol.iterator]();\n        equalsState.equals = true;\n        return foldlCb(equalsCb, equalsState, firstList).equals;\n    }\n}\nexports.equals = equals;\n// concat\nvar eMax = 2;\nfunction createConcatPlan(array) {\n    var sizes = [];\n    var sum = 0;\n    for (var i_2 = 0; i_2 < array.length; ++i_2) {\n        sum += array[i_2].array.length; // FIXME: maybe only access array once\n        sizes[i_2] = array[i_2].array.length;\n    }\n    var optimalLength = Math.ceil(sum / branchingFactor);\n    var n = array.length;\n    var i = 0;\n    if (optimalLength + eMax >= n) {\n        return undefined; // no rebalancing needed\n    }\n    while (optimalLength + eMax < n) {\n        while (sizes[i] > branchingFactor - eMax / 2) {\n            // Skip nodes that are already sufficiently balanced\n            ++i;\n        }\n        // the node at this index is too short\n        var remaining = sizes[i]; // number of elements to re-distribute\n        do {\n            var size = Math.min(remaining + sizes[i + 1], branchingFactor);\n            sizes[i] = size;\n            remaining = remaining - (size - sizes[i + 1]);\n            ++i;\n        } while (remaining > 0);\n        // Shift nodes after\n        for (var j = i; j <= n - 1; ++j) {\n            sizes[j] = sizes[j + 1];\n        }\n        --i;\n        --n;\n    }\n    sizes.length = n;\n    return sizes;\n}\n/**\n * Combines the children of three nodes into an array. The last child\n * of `left` and the first child of `right is ignored as they've been\n * concatenated into `center`.\n */\nfunction concatNodeMerge(left, center, right) {\n    var array = [];\n    if (left !== undefined) {\n        for (var i = 0; i < left.array.length - 1; ++i) {\n            array.push(left.array[i]);\n        }\n    }\n    for (var i = 0; i < center.array.length; ++i) {\n        array.push(center.array[i]);\n    }\n    if (right !== undefined) {\n        for (var i = 1; i < right.array.length; ++i) {\n            array.push(right.array[i]);\n        }\n    }\n    return array;\n}\nfunction executeConcatPlan(merged, plan, height) {\n    var result = [];\n    var sourceIdx = 0; // the current node we're copying from\n    var offset = 0; // elements in source already used\n    for (var _i = 0, plan_1 = plan; _i < plan_1.length; _i++) {\n        var toMove = plan_1[_i];\n        var source = merged[sourceIdx].array;\n        if (toMove === source.length && offset === 0) {\n            // source matches target exactly, reuse source\n            result.push(merged[sourceIdx]);\n            ++sourceIdx;\n        }\n        else {\n            var node = new Node(undefined, []);\n            while (toMove > 0) {\n                var available = source.length - offset;\n                var itemsToCopy = Math.min(toMove, available);\n                pushElements(source, node.array, offset, itemsToCopy);\n                if (toMove >= available) {\n                    ++sourceIdx;\n                    source = merged[sourceIdx].array;\n                    offset = 0;\n                }\n                else {\n                    offset += itemsToCopy;\n                }\n                toMove -= itemsToCopy;\n            }\n            if (height > 1) {\n                // Set sizes on children unless they are leaf nodes\n                setSizes(node, height - 1);\n            }\n            result.push(node);\n        }\n    }\n    return result;\n}\n/**\n * Takes three nodes and returns a new node with the content of the\n * three nodes. Note: The returned node does not have its size table\n * set correctly. The caller must do that.\n */\nfunction rebalance(left, center, right, height, top) {\n    var merged = concatNodeMerge(left, center, right);\n    var plan = createConcatPlan(merged);\n    var balanced = plan !== undefined ? executeConcatPlan(merged, plan, height) : merged;\n    if (balanced.length <= branchingFactor) {\n        if (top === true) {\n            return new Node(undefined, balanced);\n        }\n        else {\n            // Return a single node with extra height for balancing at next\n            // level\n            return new Node(undefined, [\n                setSizes(new Node(undefined, balanced), height)\n            ]);\n        }\n    }\n    else {\n        return new Node(undefined, [\n            setSizes(new Node(undefined, balanced.slice(0, branchingFactor)), height),\n            setSizes(new Node(undefined, balanced.slice(branchingFactor)), height)\n        ]);\n    }\n}\nfunction concatSubTree(left, lDepth, right, rDepth, isTop) {\n    if (lDepth > rDepth) {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, right, rDepth, false);\n        return rebalance(left, c, undefined, lDepth, isTop);\n    }\n    else if (lDepth < rDepth) {\n        var c = concatSubTree(left, lDepth, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(undefined, c, right, rDepth, isTop);\n    }\n    else if (lDepth === 0) {\n        return new Node(undefined, [left, right]);\n    }\n    else {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(left, c, right, lDepth, isTop);\n    }\n}\nfunction getHeight(node) {\n    if (node.array[0] instanceof Node) {\n        return 1 + getHeight(node.array[0]);\n    }\n    else {\n        return 0;\n    }\n}\n/**\n * Takes a RRB-tree and a node tail. It then appends the node to the\n * tree.\n * @param l The subject for appending. `l` will be mutated. Nodes in\n * the tree will _not_ be mutated.\n * @param node The node that should be appended to the tree.\n */\nfunction appendNodeToTree(l, node) {\n    if (l.root === undefined) {\n        // The old list has no content in tree, all content is in affixes\n        if (getPrefixSize(l) === 0) {\n            l.bits = setPrefix(node.array.length, l.bits);\n            l.prefix = reverseArray(node.array);\n        }\n        else {\n            l.root = node;\n        }\n        return l;\n    }\n    var depth = getDepth(l);\n    var index = l.length - 1 - getPrefixSize(l);\n    var nodesToCopy = 0;\n    var nodesVisited = 0;\n    var shift = depth * 5;\n    var currentNode = l.root;\n    if (Math.pow(32, (depth + 1)) < index) {\n        shift = 0; // there is no room\n        nodesVisited = depth;\n    }\n    while (shift > 5) {\n        var childIndex = void 0;\n        if (currentNode.sizes === undefined) {\n            // does not have size table\n            childIndex = (index >> shift) & mask;\n            index &= ~(mask << shift); // wipe just used bits\n        }\n        else {\n            childIndex = currentNode.array.length - 1;\n            index -= currentNode.sizes[childIndex - 1];\n        }\n        nodesVisited++;\n        if (childIndex < mask) {\n            // we are not going down the far right path, this implies that\n            // there is still room in the current node\n            nodesToCopy = nodesVisited;\n        }\n        currentNode = currentNode.array[childIndex];\n        if (currentNode === undefined) {\n            // This will only happened in a pvec subtree. The index does not\n            // exist so we'll have to create a new path from here on.\n            nodesToCopy = nodesVisited;\n            shift = 5; // Set shift to break out of the while-loop\n        }\n        shift -= 5;\n    }\n    if (shift !== 0) {\n        nodesVisited++;\n        if (currentNode.array.length < branchingFactor) {\n            // there is room in the found node\n            nodesToCopy = nodesVisited;\n        }\n    }\n    if (nodesToCopy === 0) {\n        // there was no room in the found node\n        var newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);\n        var newRoot = new Node(undefined, [l.root, newPath]);\n        l.root = newRoot;\n        l.bits = incrementDepth(l.bits);\n    }\n    else {\n        var copiedNode = copyFirstK(l, l, nodesToCopy, node.array.length);\n        var leaf = appendEmpty(copiedNode, depth - nodesToCopy);\n        leaf.array.push(node);\n    }\n    return l;\n}\n/**\n * Traverses down the right edge of the tree and copies k nodes\n * @param oldList\n * @param newList\n * @param k The number of nodes to copy. Will always be at least 1.\n * @param leafSize The number of elements in the leaf that will be inserted.\n */\nfunction copyFirstK(oldList, newList, k, leafSize) {\n    var currentNode = cloneNode(oldList.root); // copy root\n    newList.root = currentNode; // install root\n    for (var i = 1; i < k; ++i) {\n        var index = currentNode.array.length - 1;\n        if (currentNode.sizes !== undefined) {\n            currentNode.sizes[index] += leafSize;\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        // Install the copied node\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    if (currentNode.sizes !== undefined) {\n        currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);\n    }\n    return currentNode;\n}\nfunction appendEmpty(node, depth) {\n    if (depth === 0) {\n        return node;\n    }\n    var current = new Node(undefined, []);\n    node.array.push(current);\n    for (var i = 1; i < depth; ++i) {\n        var newNode = new Node(undefined, []);\n        current.array[0] = newNode;\n        current = newNode;\n    }\n    return current;\n}\n/*\nfunction concatSuffix<A>(\n  left: A[], lSize: number, right: A[], rSize: number\n): A[] {\n  const newArray = new Array(lSize + rSize);\n  for (let i = 0; i < lSize; ++i) {\n    newArray[i] = left[i];\n  }\n  for (let i = 0; i < rSize; ++i) {\n    newArray[lSize + i] = right[i];\n  }\n  return newArray;\n}\n*/\nvar concatBuffer = new Array(3);\nfunction concatAffixes(left, right) {\n    // TODO: Try and find a neat way to reduce the LOC here\n    var nr = 0;\n    var arrIdx = 0;\n    var i = 0;\n    var length = getSuffixSize(left);\n    concatBuffer[nr] = [];\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx] = left.suffix[i];\n        if (++arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n    }\n    length = getPrefixSize(right);\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx] = right.prefix[right.prefix.length - 1 - i];\n        if (++arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n    }\n    length = getSuffixSize(right);\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx] = right.suffix[i];\n        if (++arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n    }\n    return nr;\n}\nfunction concat(left, right) {\n    if (left.length === 0) {\n        return right;\n    }\n    else if (right.length === 0) {\n        return left;\n    }\n    var newSize = left.length + right.length;\n    var rightSuffixSize = getSuffixSize(right);\n    var newList = cloneList(left);\n    if (right.root === undefined) {\n        // right is nothing but a prefix and a suffix\n        var nrOfAffixes = concatAffixes(left, right);\n        for (var i = 0; i < nrOfAffixes; ++i) {\n            newList = appendNodeToTree(newList, new Node(undefined, concatBuffer[i]));\n            newList.length += concatBuffer[i].length;\n            // wipe pointer, otherwise it might end up keeping the array alive\n            concatBuffer[i] = undefined;\n        }\n        newList.length = newSize;\n        newList.suffix = concatBuffer[nrOfAffixes];\n        newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);\n        concatBuffer[nrOfAffixes] = undefined;\n        return newList;\n    }\n    else {\n        newList = appendNodeToTree(newList, suffixToNode(left.suffix));\n        newList.length += getSuffixSize(left);\n        newList = appendNodeToTree(newList, prefixToNode(right.prefix));\n        var newNode = concatSubTree(newList.root, getDepth(newList), right.root, getDepth(right), true);\n        var newDepth = getHeight(newNode);\n        setSizes(newNode, newDepth);\n        var bits = createBits(newDepth, getPrefixSize(newList), rightSuffixSize);\n        // FIXME: Return `newList` here\n        return new List(bits, 0, newSize, newNode, right.suffix, newList.prefix);\n    }\n}\nexports.concat = concat;\nfunction update(index, a, l) {\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    var newList = cloneList(l);\n    if (index < prefixSize) {\n        var newPrefix = copyArray(newList.prefix);\n        newPrefix[newPrefix.length - index - 1] = a;\n        newList.prefix = newPrefix;\n    }\n    else if (index >= l.length - suffixSize) {\n        var newSuffix = copyArray(newList.suffix);\n        newSuffix[index - (l.length - suffixSize)] = a;\n        newList.suffix = newSuffix;\n    }\n    else {\n        newList.root = updateNode(l.root, getDepth(l), index - prefixSize + l.offset, l.offset, a);\n    }\n    return newList;\n}\nexports.update = update;\nfunction adjust(f, index, l) {\n    return update(index, f(nth(index, l)), l);\n}\nexports.adjust = adjust;\n// slice and slice based functions\nvar newAffix;\nfunction sliceLeft(tree, depth, index, offset) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    if (depth === 0) {\n        newAffix = tree.array.slice(path).reverse();\n        // this leaf node is moved up as a suffix so there is nothing here\n        // after slicing\n        return undefined;\n    }\n    else {\n        // slice the child\n        var child = sliceLeft(tree.array[path], depth - 1, index, path === 0 ? offset : 0);\n        if (child === undefined) {\n            // there is nothing in the child after slicing so we don't include it\n            ++path;\n            if (path === tree.array.length) {\n                return undefined;\n            }\n        }\n        var array = tree.array.slice(path);\n        if (child !== undefined) {\n            array[0] = child;\n        }\n        return new Node(tree.sizes, array); // FIXME: handle the size table\n    }\n}\nfunction sliceRight(tree, depth, index, offset) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    if (depth === 0) {\n        newAffix = tree.array.slice(0, path + 1);\n        // this leaf node is moved up as a suffix so there is nothing here\n        // after slicing\n        return undefined;\n    }\n    else {\n        // slice the child, note that we subtract 1 then the radix lookup\n        // algorithm can find the last element that we want to include\n        // and sliceRight will do a slice that is inclusive on the index.\n        var child = sliceRight(tree.array[path], depth - 1, index, path === 0 ? offset : 0);\n        if (child === undefined) {\n            // there is nothing in the child after slicing so we don't include it\n            --path;\n            if (path === -1) {\n                return undefined;\n            }\n        }\n        // note that we add 1 to the path since we want the slice to be\n        // inclusive on the end index. Only at the leaf level do we want\n        // to do an exclusive slice.\n        var array = tree.array.slice(0, path + 1);\n        if (child !== undefined) {\n            array[array.length - 1] = child;\n        }\n        return new Node(tree.sizes, array); // FIXME: handle the size table\n    }\n}\nfunction sliceTreeList(from, to, tree, depth, offset, l) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var pathLeft = ((from >> (depth * branchBits)) & mask) - curOffset;\n    var pathRight = ((to >> (depth * branchBits)) & mask) - curOffset;\n    if (depth === 0) {\n        // we are slicing a piece off a leaf node\n        l.prefix = emptyAffix;\n        l.suffix = tree.array.slice(pathLeft, pathRight + 1);\n        l.root = undefined;\n        l.bits = setSuffix(pathRight - pathLeft + 1, 0);\n        return l;\n    }\n    else if (pathLeft === pathRight) {\n        // Both ends are located in the same subtree, this means that we\n        // can reduce the height\n        // l.bits = decrementDepth(l.bits);\n        // return sliceTreeList(from, to, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);\n        var rec = sliceTreeList(from, to, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);\n        if (rec.root !== undefined) {\n            rec.root = new Node(undefined, [rec.root]);\n        }\n        return rec;\n    }\n    else {\n        var childLeft = sliceLeft(tree.array[pathLeft], depth - 1, from, pathLeft === 0 ? offset : 0);\n        l.bits = setPrefix(newAffix.length, l.bits);\n        l.prefix = newAffix;\n        var childRight = sliceRight(tree.array[pathRight], depth - 1, to, 0);\n        l.bits = setSuffix(newAffix.length, l.bits);\n        l.suffix = newAffix;\n        if (childLeft === undefined) {\n            ++pathLeft;\n        }\n        if (childRight === undefined) {\n            --pathRight;\n        }\n        if (pathLeft > pathRight) {\n            // there is no tree left\n            l.bits = setDepth(0, l.bits);\n            l.root = undefined;\n            // } else if (pathLeft === pathRight) {\n            // height can be reduced\n            // l.bits = decrementDepth(l.bits);\n            // l.root = childLeft === undefined ? childRight : childLeft;\n        }\n        else {\n            var array = tree.array.slice(pathLeft, pathRight + 1);\n            if (childLeft !== undefined) {\n                array[0] = childLeft;\n            }\n            if (childRight !== undefined) {\n                array[array.length - 1] = childRight;\n            }\n            l.root = new Node(tree.sizes, array);\n        }\n        return l;\n    }\n}\nfunction slice(from, to, l) {\n    var bits = l.bits, length = l.length;\n    to = Math.min(length, to);\n    // handle negative indices\n    if (from < 0) {\n        from = length + from;\n    }\n    if (to < 0) {\n        to = length + to;\n    }\n    if (to <= from || to <= 0 || length <= from) {\n        return empty();\n    }\n    // return list unchanged if we are slicing nothing off\n    if (from <= 0 && length <= to) {\n        return l;\n    }\n    var newLength = to - from;\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    // both indices lie in the prefix\n    if (to <= prefixSize) {\n        return new List(setPrefix(newLength, 0), 0, newLength, undefined, emptyAffix, l.prefix.slice(l.prefix.length - to, l.prefix.length - from));\n    }\n    var suffixStart = length - suffixSize;\n    // both indices lie in the suffix\n    if (suffixStart <= from) {\n        return new List(setSuffix(newLength, 0), 0, newLength, undefined, l.suffix.slice(from - suffixStart, to - suffixStart), emptyAffix);\n    }\n    var newList = cloneList(l);\n    // both indices lie in the tree\n    if (prefixSize <= from && to <= length - suffixSize) {\n        sliceTreeList(from - prefixSize + l.offset, to - prefixSize + l.offset - 1, l.root, getDepth(l), l.offset, newList);\n        if (newList.root !== undefined) {\n            newList.offset += from - prefixSize + getPrefixSize(newList);\n        }\n        newList.length = to - from;\n        return newList;\n    }\n    // we need to slice something off of the left\n    if (0 < from) {\n        if (from < prefixSize) {\n            // do a cheap slice by setting prefix length\n            bits = setPrefix(prefixSize - from, bits);\n        }\n        else {\n            // if we're here `to` can't lie in the tree, so we can set the\n            // root\n            newList.root = sliceLeft(newList.root, getDepth(l), from - prefixSize + l.offset, l.offset);\n            bits = setPrefix(newAffix.length, bits);\n            newList.offset += from - prefixSize + newAffix.length;\n            prefixSize = newAffix.length;\n            newList.prefix = newAffix;\n        }\n        newList.length -= from;\n    }\n    if (to < length) {\n        if (length - to < suffixSize) {\n            bits = setSuffix(suffixSize - (length - to), bits);\n        }\n        else {\n            newList.root = sliceRight(newList.root, getDepth(l), to - prefixSize + newList.offset - 1, newList.offset);\n            if (newList.root === undefined) {\n                bits = setDepth(0, bits);\n            }\n            bits = setSuffix(newAffix.length, bits);\n            newList.suffix = newAffix;\n        }\n        newList.length -= length - to;\n    }\n    newList.bits = bits;\n    return newList;\n}\nexports.slice = slice;\nfunction take(n, l) {\n    return slice(0, n, l);\n}\nexports.take = take;\nfunction findNotIndexCb(value, state) {\n    ++state.index;\n    return state.predicate(value);\n}\nfunction takeWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: -1 }, l).index;\n    return slice(0, index, l);\n}\nexports.takeWhile = takeWhile;\nfunction dropWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: -1 }, l).index;\n    return slice(index, l.length, l);\n}\nexports.dropWhile = dropWhile;\nfunction takeLast(n, l) {\n    return slice(l.length - n, l.length, l);\n}\nexports.takeLast = takeLast;\nfunction splitAt(index, l) {\n    return [slice(0, index, l), slice(index, l.length, l)];\n}\nexports.splitAt = splitAt;\nfunction remove(from, amount, l) {\n    return concat(slice(0, from, l), slice(from + amount, l.length, l));\n}\nexports.remove = remove;\nfunction drop(n, l) {\n    return slice(n, l.length, l);\n}\nexports.drop = drop;\nfunction dropLast(n, l) {\n    return slice(0, l.length - n, l);\n}\nexports.dropLast = dropLast;\nfunction pop(l) {\n    return slice(0, -1, l);\n}\nexports.pop = pop;\nexports.init = pop;\nfunction tail(l) {\n    return slice(1, l.length, l);\n}\nexports.tail = tail;\nfunction arrayPush(array, a) {\n    array.push(a);\n    return array;\n}\nfunction toArray(l) {\n    return foldl(arrayPush, [], l);\n}\nexports.toArray = toArray;\nfunction fromArray(array) {\n    var l = empty();\n    for (var i = 0; i < array.length; ++i) {\n        l = append(array[i], l);\n    }\n    return l;\n}\nexports.fromArray = fromArray;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar map_1 = __webpack_require__(0);\r\nvar ImmuSet = /** @class */ (function () {\r\n    function ImmuSet(values) {\r\n        if (values) {\r\n            var entries = [];\r\n            for (var _i = 0, _a = values; _i < _a.length; _i++) {\r\n                var v = _a[_i];\r\n                entries.push([v, v]);\r\n            }\r\n            this._map = new map_1.default(entries);\r\n        }\r\n        else {\r\n            this._map = new map_1.default();\r\n        }\r\n    }\r\n    Object.defineProperty(ImmuSet.prototype, \"size\", {\r\n        get: function () {\r\n            return this._map.size;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ImmuSet.prototype[Symbol.iterator] = function () {\r\n        return this._map.keys();\r\n    };\r\n    ImmuSet.prototype.add = function (value) {\r\n        var map = this._map.set(value, value);\r\n        if (map.size > this._map.size) {\r\n            var newSet = new ImmuSet();\r\n            newSet._map = map;\r\n            return newSet;\r\n        }\r\n        return this;\r\n    };\r\n    ImmuSet.prototype.entries = function () {\r\n        return this._map.entries();\r\n    };\r\n    ImmuSet.prototype.keys = function () {\r\n        return this._map.keys();\r\n    };\r\n    ImmuSet.prototype.values = function () {\r\n        return this._map.values();\r\n    };\r\n    ImmuSet.prototype.forEach = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        this._map.forEach(function (v1, v2, _) { return callbackfn(v1, v2, _this); }, thisArg);\r\n    };\r\n    ImmuSet.prototype.has = function (value) {\r\n        return this._map.has(value);\r\n    };\r\n    return ImmuSet;\r\n}());\r\nexports.default = ImmuSet;\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// hydux.collections.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 10c5a48cd516f4b3c1c4","interface TreeNode<K, V> {\n  value: [K, V],\n  left: Tree<K, V>,\n  right: Tree<K, V>,\n  height: number,\n}\n\ntype Tree<K, V> = TreeNode<K, V> | null\n\nlet keys = [] as any[]\nfunction getType(key: any) {\n  const t: string = Object.prototype.toString.call(key)\n  return t.slice(8, -1).toLowerCase()\n}\n\nlet objUid = 0\nlet objUidKey = typeof Symbol !== 'undefined' ? Symbol('_hmuid_') : '_hmuid_'\nlet objUidMap = typeof WeakMap !== 'undefined' ? new WeakMap<object, number>() : null\nfunction hash(key: any) {\n  switch (getType(key)) {\n    case 'undefined':\n    case 'null':\n    case 'boolean':\n    case 'number':\n    case 'regexp':\n      return key + ''\n\n    case 'date':\n      return '' + key.getTime()\n\n    case 'string':\n      return '' + key\n\n    case 'array':\n      return '' + (key as any[]).map(k => hash(k)).join('')\n\n    default:\n      if (objUidMap) {\n        let uid = objUidMap.get(key)\n        if (!uid) {\n          uid = ++objUid\n          objUidMap.set(key, uid)\n        }\n        return uid\n      }\n      // TODO: Don't use expandos when Object.defineProperty is not available?\n      if (!key.hasOwnProperty(objUidKey)) {\n        key[objUidKey] = ++objUid\n        hide(key, objUidKey)\n      }\n\n      return '' + key[objUidKey]\n  }\n}\n\nfunction hide(obj, prop) {\n  // Make non iterable if supported\n  if (Object.defineProperty) {\n    Object.defineProperty(obj, prop, { enumerable: false })\n  }\n}\n\nfunction height<K, V>(t: Tree<K, V>) {\n  if (t) {\n    return t.height\n  } else {\n    return 0\n  }\n}\n\nfunction create<K, V>(left: Tree<K, V>, value: [K, V], right: Tree<K, V>): TreeNode<K, V> {\n  return {\n    value,\n    left,\n    right,\n    height: Math.max(height(left), height(right)) + 1,\n  }\n}\n\nfunction impossible(): never {\n  throw new Error('[hydux-mutator/map] imposible')\n}\n\nfunction balance<K, V>(left: Tree<K, V>, value: [K, V], right: Tree<K, V>): Tree<K, V> {\n  let leftHeight = height(left)\n  let rightHeit = height(right)\n  if (leftHeight > rightHeit + 2) {\n    if (!left) {\n      return impossible()\n    } else {\n      if (height(left.left) >= height(left.right)) {\n        return create(left.left, left.value, create(left.right, value, right))\n      } else if (!left.right) {\n        return impossible()\n      } else {\n        return create(create(left.left, left.value, left.right.left), left.right.value, create(left.right.right, value, right))\n      }\n    }\n  } else if (rightHeit > leftHeight + 2) {\n    if (!right) {\n      return impossible()\n    } else {\n      if (height(right.right) >= height(right.right)) {\n        return create(create(left, value, right.left), right.value, right.right)\n      } else if (!right.left) {\n        return impossible()\n      } else {\n        return create(create(left, value, right.left.left), right.left.value, create(right.left.right, right.value, right.right))\n      }\n    }\n  } else {\n    return create(left, value, right)\n  }\n}\n\nfunction add<K, V>(key: K, value: V, tree: Tree<K, V>): [boolean, Tree<K, V>] {\n  if (tree) {\n    const newKeyHash = hash(key)\n    const rootKeyHash = hash(tree.value[0])\n    if (newKeyHash === rootKeyHash) {\n      return [false, tree]\n    } else if (newKeyHash < rootKeyHash) {\n      const res = add(key, value, tree.left)\n      return [res[0], balance(res[1], tree.value, tree.right)]\n    } else {\n      const res = add(key, value, tree.right)\n      return [res[0], balance(tree.left, tree.value, res[1])]\n    }\n  } else {\n    return [true, create(null, [key, value], null)]\n  }\n}\n\nfunction minElt<K, V>(value: [K, V], tree: Tree<K, V>) {\n  if (!tree) {\n    return value\n  } else if (!tree.left) {\n    return tree.value\n  } else {\n    return minElt(tree.value, tree.left)\n  }\n}\n\nfunction removeMinElt<K, V>(left: Tree<K, V>, value: [K, V], right: Tree<K, V>) {\n  if (!left) {\n    return right\n  } else {\n    return balance(removeMinElt(left.left, left.value, left.right), value, right)\n  }\n}\n\nfunction internalMerge<K, V>(left: Tree<K, V>, right: Tree<K, V>) {\n  if (!left) {\n    return right\n  } else if (!right) {\n    return left\n  } else if (right) {\n    return balance(left, minElt(right.value, right), removeMinElt(right.left, right.value, right.right))\n  }\n  return impossible()\n}\n\nfunction remove<K, V>(key: K, tree: Tree<K, V>): [boolean, Tree<K, V>] {\n  if (!tree) {\n    return [false, null]\n  } else {\n    let keyHash = hash(key)\n    let oldKeyHash = hash(tree.value[0])\n    if (keyHash === oldKeyHash) {\n      return [true, internalMerge(tree.left, tree.right)]\n    } else if (keyHash < oldKeyHash) {\n      const res = remove(key, tree.left)\n      return [res[0], balance(res[1], tree.value, tree.right)]\n    } else {\n      const res = remove(key, tree.right)\n      return [res[0], balance(tree.left, tree.value, res[1])]\n    }\n  }\n}\n\nfunction mem<K, V>(key: K, tree: Tree<K, V>): boolean {\n  if (!tree) {\n    return false\n  }\n  let keyHash = hash(key)\n  let oldKeyHash = hash(tree.value[0])\n  return keyHash === oldKeyHash || mem(key, (keyHash < oldKeyHash) ? tree.left : tree.right)\n}\nfunction get<K, V>(key: K, tree: Tree<K, V>): V | undefined {\n  if (!tree) {\n    return void 0\n  }\n  let keyHash = hash(key)\n  let oldKeyHash = hash(tree.value[0])\n  if (keyHash === oldKeyHash) {\n    return tree.value[1]\n  }\n  return get(key, (keyHash < oldKeyHash) ? tree.left : tree.right)\n}\n\nfunction unimplemented(): never {\n  throw new Error('unimplemented')\n}\n\nfunction * treeKeys<K, V, T>(tree: Tree<K, V>, getVal: (v: [K, V]) => T): IterableIterator<T> {\n  if (!tree) {\n    return\n  }\n  if (tree.left) {\n    for (const k of treeKeys(tree.left, getVal) as any) {\n      yield k\n    }\n  }\n  yield getVal(tree.value)\n  if (tree.right) {\n    for (const k of treeKeys(tree.right, getVal) as any) {\n      yield k\n    }\n  }\n}\n\nexport default class ImmuMap<K, V> implements ReadonlyMap<K, V> {\n  get size() {\n    return this._size\n  }\n  private _size: number\n  private _tree: Tree<K, V>\n\n  constructor(entries?: ReadonlyArray<[K, V]> | Iterable<[K, V]>) {\n    this._tree = null\n    this._size = 0\n    if (entries) {\n      for (const [k, v] of entries as any) {\n        const [added, tree] = add(k, v, this._tree)\n        this._tree = tree\n        if (added) {\n          this._size++\n        }\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n  forEach(callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void, thisArg?: any) {\n    for (const [key, value] of this.entries() as any) {\n      callbackfn.call(thisArg, value, key, this)\n    }\n  }\n  get(key: K) {\n    return get(key, this._tree)\n  }\n  has(key: K) {\n    return mem(key, this._tree)\n  }\n  set(key: K, value: V): ImmuMap<K, V> {\n    const [added, tree] = add(key, value, this._tree)\n    if (added) {\n      const map = new ImmuMap<K, V>()\n      map._tree = tree\n      map._size++\n      return map\n    } else {\n      return this\n    }\n  }\n  delete(key: K): ImmuMap<K, V> {\n    const [removed, tree] = remove(key, this._tree)\n    if (removed) {\n      const map = new ImmuMap<K, V>()\n      map._tree = tree\n      map._size--\n      return map\n    } else {\n      return this\n    }\n  }\n  keys() {\n    return treeKeys(this._tree, v => v[0])\n  }\n  values() {\n    return treeKeys(this._tree, v => v[1])\n  }\n  entries() {\n    return treeKeys(this._tree, v => v)\n  }\n}\n\n// let v = null as Tree<number, number>\n\n// const l = Array(10).fill(0).map((_, i) => i)\n\n// l.map(i => v = add(i, i + 1, v))\n// function prettyPrint(x) {\n//   let opts = { depth: null, colors: 'auto' }\n//   // let s = require('util').inspect(x, opts)\n//   // console.log (s)\n// }\n// prettyPrint(v)\n// l.map(i => {\n//   if (!mem(i, v)) {\n//     impossible()\n//   }\n// })\n\n// l.map(i => {\n//   if (get(i, v) !== i + 1) {\n//     impossible()\n//   }\n// })\n\n// for (const key of treeKeys(v, v => v[0])) {\n//   console.log('iter key', key)\n// }\n\n// l.map(i => {\n//   v = remove(i, v)\n// })\n// prettyPrint(v)\n// if (v) {\n//   impossible()\n// } else {\n//   console.log('succuss')\n// }\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/map.ts","import ImmuList from './list'\nimport ImmuMap from './map'\nimport ImmuSet from './set'\n\nexport { ImmuList, ImmuMap, ImmuSet }\nexport default { ImmuList, ImmuMap, ImmuSet }\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/index.ts","import * as List from '@funkia/list'\n\nfunction * iter<T, U>(list: List.List<T>, getter: (v: T) => U): IterableIterator<U> {\n  for (const item of (list as any)) {\n    yield getter(item)\n  }\n  return\n}\n\nfunction * iteri(len: number): IterableIterator<number> {\n  for (let i = 0; i < len; i++) {\n    yield i\n  }\n}\n\nexport default class ImmuList<T> {\n  get length() {\n    return this._list.length\n  }\n  private _list: List.List<T>\n\n  constructor(values?: T[]) {\n    if (values) {\n      this._list = List.fromArray(values)\n    } else {\n      this._list = List.empty()\n    }\n  }\n  toString(): string {\n    return List.toArray(this._list).toString()\n  }\n  toLocaleString(): string {\n    return List.toArray(this._list).toLocaleString()\n  }\n  get(i: number) {\n    return List.nth(i, this._list)\n  }\n  set(i: number, val: T): ImmuList<T> {\n    const list = List.update(i, val, this._list)\n    return this._copy(list)\n  }\n  concat(...items: (ImmuList<T> | Array<T> | T)[]): ImmuList<T> {\n    let list = this._list\n    for (const item of items) {\n      if (item instanceof ImmuList) {\n        list = List.concat(list, item._list)\n      } else if (item instanceof Array) {\n        list = item.reduce((l, i) => List.append(i, l), list)\n      } else {\n        list = List.append(item, list)\n      }\n    }\n    if (list.length > this._list.length) {\n      return this._copy(list)\n    }\n    return this\n  }\n  join(separator?: string | undefined): string {\n    let sep = separator || ','\n    return List.join(sep, this._list as any)\n  }\n  slice(start?: number | undefined, end?: number | undefined) {\n    const newList = List.slice(start || 0, end || this._list.length, this._list)\n    if (newList.length !== this._list.length) {\n      return this._copy(newList)\n    }\n    return this\n  }\n  indexOf(searchElement: T, fromIndex?: number | undefined): number {\n    let list = this._list\n    if (fromIndex) {\n      list = List.slice(fromIndex, this._list.length, list)\n    }\n    return List.indexOf(searchElement, list)\n  }\n  every(callbackfn: (value: T, index: number, array: this) => boolean, thisArg?: any): boolean {\n    let i = 0\n    return List.every(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, this._list)\n  }\n  some(callbackfn: (value: T, index: number, array: this) => boolean, thisArg?: any): boolean {\n    let i = 0\n    return List.some(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, this._list)\n  }\n  forEach(callbackfn: (value: T, index: number, array: this) => void, thisArg?: any): void {\n    let i = 0\n    List.every(v => {\n      callbackfn.call(thisArg, v, i++, this)\n      return true\n    }, this._list)\n  }\n  map<U>(callbackfn: (value: T, index: number, array: this) => U, thisArg?: any): ImmuList<U> {\n    let i = 0\n    const list = List.map(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, this._list)\n    return this._copy(list)\n  }\n  filter(callbackfn: (value: T, index: number, array: this) => boolean, thisArg?: any): ImmuList<T> {\n    let i = 0\n    const list = List.filter(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, this._list)\n    if (list.length !== this._list.length) {\n      return this._copy(list)\n    }\n    return this\n  }\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: this, ) => U, initialValue: U, thisArg?: any): U {\n    let i = 0\n    return List.foldl(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, initialValue, this._list)\n  }\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: this) => U, initialValue: U, thisArg?: any): U {\n    let i = 0\n    return List.foldr(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, initialValue, this._list)\n  }\n  [Symbol.iterator](): IterableIterator<T> {\n    return iter(this._list, v => v)\n  }\n  entries(): IterableIterator<[number, T]> {\n    let i = 0\n    return iter(this._list, v => [i++, v] as [number, T])\n  }\n  keys(): IterableIterator<number> {\n    return iteri(this._list.length)\n  }\n  values(): IterableIterator<T> {\n    return iter(this._list, v => v)\n  }\n  find(predicate: (value: T, index: number, obj: this) => boolean, thisArg?: any): T | undefined {\n    let i = 0\n    return List.find(v => {\n      return predicate.call(thisArg, v, i++, this)\n    }, this._list)\n  }\n  findIndex(predicate: (value: T, index: number, obj: this) => boolean, thisArg?: any): number {\n    let i = 0\n    return List.findIndex(v => {\n      return predicate.call(thisArg, v, i++, this)\n    }, this._list)\n  }\n  private _copy<T>(list: List.List<T>) {\n    const newImmuList = new ImmuList<T>()\n    newImmuList._list = list\n    return newImmuList\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/list.ts",null,"import ImmuMap from './map'\n\nexport default class ImmuSet<T> implements ReadonlySet<T> {\n  get size() {\n    return this._map.size\n  }\n  private _map: ImmuMap<T, T>\n  constructor(values?: ReadonlyArray<T> | Iterable<T>) {\n    if (values) {\n      let entries = [] as [T, T][]\n      for (const v of values as any) {\n        entries.push([v, v])\n      }\n      this._map = new ImmuMap(entries)\n    } else {\n      this._map = new ImmuMap()\n    }\n  }\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._map.keys()\n  }\n  add(value: T): ImmuSet<T> {\n    const map = this._map.set(value, value)\n    if (map.size > this._map.size) {\n      const newSet = new ImmuSet<T>()\n      newSet._map = map\n      return newSet\n    }\n    return this\n  }\n  entries(): IterableIterator<[T, T]> {\n    return this._map.entries()\n  }\n  keys(): IterableIterator<T> {\n    return this._map.keys()\n  }\n  values(): IterableIterator<T> {\n    return this._map.values()\n  }\n  forEach(callbackfn: (value: T, value2: T, set: ReadonlySet<T>) => void, thisArg?: any): void {\n    this._map.forEach((v1, v2, _) => callbackfn(v1, v2, this), thisArg)\n  }\n  has(value: T): boolean {\n    return this._map.has(value)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/set.ts"],"sourceRoot":""}