{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///hydux.collections.js","webpack:///webpack/bootstrap c62b0604a7717f54c7fa","webpack:///./src/utils.ts","webpack:///./src/collections/utils.ts","webpack:///./src/collections/map.ts","webpack:///./src/collections/index.ts","webpack:///./src/collections/list.ts","webpack:///../src/index.ts","webpack:///./src/collections/set.ts"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","isSet","val","isFn","fn","isPojo","obj","constructor","error","args","_i","arguments","length","console","apply","concat","isObj","iterMap","list","cb","list_1","item","iter","__generator","_a","label","Array","sent","Symbol","iterator","next","done","forEach","getType","key","toString","slice","toLowerCase","defaultHash","getTime","map","k","join","objUidMap","uid","objUid","set","objUidKey","hide","prop","thisArg","body","verb","v","step","op","f","TypeError","_","y","t","ops","pop","trys","push","e","g","throw","return","WeakMap","height","create","left","right","Math","max","impossible","Error","balance","leftHeight","rightHeit","add","tree","hash","newKeyHash","treeKey","treeValue","rootKeyHash","AddStatus","none","updated","res","added","minElt","removeMinElt","internalMerge","remove","keyHash","oldKeyHash","mem","iterTree","getVal","iter_1","iter_2","utils_1","utils_2","ImmuMap","entries","_this","_tree","_size","_hash","_b","status","callbackfn","has","clear","delete","removed","keys","values","toJSON","String","default","ImmuList","map_1","set_1","ImmuSet","iteri","len","List","_list","fromArray","empty","toArray","toLocaleString","nth","update","_new","from","amount","includes","append","prepend","first","last","tail","edit","editWithAny","items","reduce","separator","sep","start","end","newList","indexOf","searchElement","fromIndex","every","some","foldl","undefined","filter","initialValue","acc","reduceRight","foldr","find","predicate","findIndex","newImmuList","setEquals","equals","elementEquals","createPath","depth","current","Node","copyArray","source","array","pushElements","target","offset","copyIndices","sourceStart","targetStart","arrayPrepend","newLength","result","nodePrepend","size","node","sizes","reverseArray","reverse","arrayFirst","arrayLast","updateNode","index","curOffset","branchBits","mask","path","nodeNthDense","nodeNth","cloneNode","suffixToNode","suffix","prefixToNode","prefix","setSizes","sum","sizeTable","sizeOfSubtree","lastSize","affixPush","a","newArray","getSuffixSize","bits","affixMask","getPrefixSize","affixBits","getDepth","setPrefix","setSuffix","setDepth","incrementPrefix","incrementSuffix","incrementDepth","createBits","prefixSize","suffixSize","cloneList","prependNodeToTree","newPrefix","copyLeft","leafSize","currentNode","i_1","newNode","prependSizes","newSizes","prependTopTree","newOffset","branchingFactor","pow","copyableCount","nodesTraversed","copiedNode","prependDense","parent_1","prependableNode","prepended","newSuffix","suffixNode","appendNodeToTree","elements","elements_1","pair","second","emptyAffix","repeat","times","mapArray","mapNode","mapAffix","pluck","range","foldlSuffix","foldlPrefix","foldlNode","initial","reject","b","foldrSuffix","foldrPrefix","foldrNode","flatten","nested","foldlSuffixCb","state","foldlPrefixCb","foldlNodeCb","foldlCb","everyCb","someCb","findCb","indexOfCb","found","element","findIndexCb","containsCb","containsState","equalsCb","value2","firstList","secondList","equalsState","createConcatPlan","i_2","optimalLength","ceil","eMax","remaining","min","j","concatNodeMerge","center","executeConcatPlan","merged","plan","sourceIdx","plan_1","toMove","available","itemsToCopy","rebalance","top","balanced","concatSubTree","lDepth","rDepth","isTop","getHeight","nodesToCopy","nodesVisited","shift","childIndex","newPath","newRoot","appendEmpty","copyFirstK","oldList","concatAffixes","nr","arrIdx","concatBuffer","newSize","rightSuffixSize","nrOfAffixes","newDepth","adjust","sliceLeft","newAffix","child","sliceRight","sliceTreeList","to","pathLeft","pathRight","rec","childLeft","childRight","suffixStart","take","findNotIndexCb","takeWhile","dropWhile","takeLast","splitAt","drop","dropLast","arrayPush","space","ListIterator","iteratorDone","stack","indices","prefixLeft","goUp","idx","incrementIndex","nextInTree","leaf","all","any","contains","init","_map","newSet","arr","v1","v2"],"mappings":"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","file":"hydux.collections.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"collections\"] = factory();\n\telse\n\t\troot[\"hydux\"] = root[\"hydux\"] || {}, root[\"hydux\"][\"collections\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"collections\"] = factory();\n\telse\n\t\troot[\"hydux\"] = root[\"hydux\"] || {}, root[\"hydux\"][\"collections\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isSet = function (val) { return typeof val !== 'undefined' && val !== null; };\r\nexports.isFn = function (fn) { return typeof fn === 'function'; };\r\nexports.isPojo = function (obj) { return !exports.isSet(obj.constructor) || obj.constructor === Object; };\r\nexports.error = function () {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return console.error.apply(console, ['[hydux-mutator]'].concat(args));\r\n};\r\nexports.isObj = function (obj) { return typeof obj === 'object' && obj; };\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction iterMap(list, cb) {\r\n    var _i, list_1, item, iter, item;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!(list instanceof Array)) return [3 /*break*/, 5];\r\n                _i = 0, list_1 = list;\r\n                _a.label = 1;\r\n            case 1:\r\n                if (!(_i < list_1.length)) return [3 /*break*/, 4];\r\n                item = list_1[_i];\r\n                return [4 /*yield*/, cb(item)];\r\n            case 2:\r\n                _a.sent();\r\n                _a.label = 3;\r\n            case 3:\r\n                _i++;\r\n                return [3 /*break*/, 1];\r\n            case 4: return [2 /*return*/];\r\n            case 5:\r\n                iter = list[Symbol.iterator]();\r\n                item = iter.next();\r\n                _a.label = 6;\r\n            case 6:\r\n                if (!!item.done) return [3 /*break*/, 9];\r\n                return [4 /*yield*/, cb(item.value)];\r\n            case 7:\r\n                _a.sent();\r\n                _a.label = 8;\r\n            case 8:\r\n                item = iter.next();\r\n                return [3 /*break*/, 6];\r\n            case 9: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nexports.iterMap = iterMap;\r\nfunction iter(list, cb) {\r\n    if (list instanceof Array) {\r\n        return list.forEach(cb);\r\n    }\r\n    var iter = list[Symbol.iterator]();\r\n    for (var item = iter.next(); !item.done; item = iter.next()) {\r\n        cb(item.value);\r\n    }\r\n}\r\nexports.iter = iter;\r\nfunction getType(key) {\r\n    var t = Object.prototype.toString.call(key);\r\n    return t.slice(8, -1).toLowerCase();\r\n}\r\nvar objUid = 0;\r\nvar objUidKey = typeof Symbol !== 'undefined' ? Symbol('_hmuid_') : '_hmuid_';\r\nvar objUidMap = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\r\nfunction defaultHash(key) {\r\n    switch (getType(key)) {\r\n        case 'undefined':\r\n        case 'null':\r\n        case 'boolean':\r\n        case 'number':\r\n        case 'regexp':\r\n            return key + '';\r\n        case 'date':\r\n            return '' + key.getTime();\r\n        case 'string':\r\n            return '' + key;\r\n        case 'array':\r\n            return '' + key.map(function (k) { return defaultHash(k); }).join('');\r\n        default:\r\n            if (objUidMap) {\r\n                var uid = objUidMap.get(key);\r\n                if (!uid) {\r\n                    uid = ++objUid;\r\n                    objUidMap.set(key, uid);\r\n                }\r\n                return '' + uid;\r\n            }\r\n            // TODO: Don't use expandos when Object.defineProperty is not available?\r\n            if (!key.hasOwnProperty(objUidKey)) {\r\n                key[objUidKey] = ++objUid;\r\n                hide(key, objUidKey);\r\n            }\r\n            return '' + key[objUidKey];\r\n    }\r\n}\r\nexports.defaultHash = defaultHash;\r\nfunction hide(obj, prop) {\r\n    // Make non iterable if supported\r\n    if (Object.defineProperty) {\r\n        Object.defineProperty(obj, prop, { enumerable: false });\r\n    }\r\n}\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(1);\r\nexports.defaultHash = utils_1.defaultHash;\r\nvar utils_2 = __webpack_require__(0);\r\nfunction height(t) {\r\n    if (t) {\r\n        return t.height;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nfunction create(left, value, right) {\r\n    return {\r\n        value: value,\r\n        left: left,\r\n        right: right,\r\n        height: Math.max(height(left), height(right)) + 1,\r\n    };\r\n}\r\nfunction impossible() {\r\n    throw new Error('[hydux-mutator/map] imposible');\r\n}\r\nfunction balance(left, value, right) {\r\n    var leftHeight = height(left);\r\n    var rightHeit = height(right);\r\n    if (leftHeight > rightHeit + 2) {\r\n        if (!left) {\r\n            return impossible();\r\n        }\r\n        else {\r\n            if (height(left.left) >= height(left.right)) {\r\n                return create(left.left, left.value, create(left.right, value, right));\r\n            }\r\n            else if (!left.right) {\r\n                return impossible();\r\n            }\r\n            else {\r\n                return create(create(left.left, left.value, left.right.left), left.right.value, create(left.right.right, value, right));\r\n            }\r\n        }\r\n    }\r\n    else if (rightHeit > leftHeight + 2) {\r\n        if (!right) {\r\n            return impossible();\r\n        }\r\n        else {\r\n            if (height(right.right) >= height(right.right)) {\r\n                return create(create(left, value, right.left), right.value, right.right);\r\n            }\r\n            else if (!right.left) {\r\n                return impossible();\r\n            }\r\n            else {\r\n                return create(create(left, value, right.left.left), right.left.value, create(right.left.right, right.value, right.right));\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return create(left, value, right);\r\n    }\r\n}\r\nvar AddStatus;\r\n(function (AddStatus) {\r\n    AddStatus[AddStatus[\"none\"] = 0] = \"none\";\r\n    AddStatus[AddStatus[\"added\"] = 1] = \"added\";\r\n    AddStatus[AddStatus[\"updated\"] = 2] = \"updated\";\r\n})(AddStatus || (AddStatus = {}));\r\nfunction add(key, value, tree, hash) {\r\n    if (tree) {\r\n        var newKeyHash = hash(key);\r\n        var _a = tree.value, treeKey = _a[0], treeValue = _a[1];\r\n        var rootKeyHash = hash(treeKey);\r\n        if (newKeyHash === rootKeyHash) {\r\n            if (treeValue === value) {\r\n                return [AddStatus.none, tree];\r\n            }\r\n            else {\r\n                return [AddStatus.updated, create(tree.left, [key, value], tree.right)];\r\n            }\r\n        }\r\n        else if (newKeyHash < rootKeyHash) {\r\n            var res = add(key, value, tree.left, hash);\r\n            return [res[0], balance(res[1], tree.value, tree.right)];\r\n        }\r\n        else {\r\n            var res = add(key, value, tree.right, hash);\r\n            return [res[0], balance(tree.left, tree.value, res[1])];\r\n        }\r\n    }\r\n    else {\r\n        return [AddStatus.added, create(null, [key, value], null)];\r\n    }\r\n}\r\nfunction minElt(value, tree) {\r\n    if (!tree) {\r\n        return value;\r\n    }\r\n    else if (!tree.left) {\r\n        return tree.value;\r\n    }\r\n    else {\r\n        return minElt(tree.value, tree.left);\r\n    }\r\n}\r\nfunction removeMinElt(left, value, right) {\r\n    if (!left) {\r\n        return right;\r\n    }\r\n    else {\r\n        return balance(removeMinElt(left.left, left.value, left.right), value, right);\r\n    }\r\n}\r\nfunction internalMerge(left, right) {\r\n    if (!left) {\r\n        return right;\r\n    }\r\n    else if (!right) {\r\n        return left;\r\n    }\r\n    else if (right) {\r\n        return balance(left, minElt(right.value, right), removeMinElt(right.left, right.value, right.right));\r\n    }\r\n    return impossible();\r\n}\r\nfunction remove(key, tree, hash) {\r\n    if (!tree) {\r\n        return [false, null];\r\n    }\r\n    else {\r\n        var keyHash = hash(key);\r\n        var oldKeyHash = hash(tree.value[0]);\r\n        if (keyHash === oldKeyHash) {\r\n            return [true, internalMerge(tree.left, tree.right)];\r\n        }\r\n        else if (keyHash < oldKeyHash) {\r\n            var res = remove(key, tree.left, hash);\r\n            return [res[0], balance(res[1], tree.value, tree.right)];\r\n        }\r\n        else {\r\n            var res = remove(key, tree.right, hash);\r\n            return [res[0], balance(tree.left, tree.value, res[1])];\r\n        }\r\n    }\r\n}\r\nfunction mem(key, tree, hash) {\r\n    if (!tree) {\r\n        return false;\r\n    }\r\n    var keyHash = hash(key);\r\n    var oldKeyHash = hash(tree.value[0]);\r\n    return keyHash === oldKeyHash || mem(key, (keyHash < oldKeyHash) ? tree.left : tree.right, hash);\r\n}\r\nfunction get(key, tree, hash) {\r\n    if (!tree) {\r\n        return void 0;\r\n    }\r\n    var keyHash = hash(key);\r\n    var oldKeyHash = hash(tree.value[0]);\r\n    if (keyHash === oldKeyHash) {\r\n        return tree.value[1];\r\n    }\r\n    return get(key, (keyHash < oldKeyHash) ? tree.left : tree.right, hash);\r\n}\r\nfunction unimplemented() {\r\n    throw new Error('unimplemented');\r\n}\r\nfunction iterTree(tree, getVal) {\r\n    var iter_1, item, iter_2, item;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!tree) {\r\n                    return [2 /*return*/];\r\n                }\r\n                if (!tree.left) return [3 /*break*/, 4];\r\n                iter_1 = iterTree(tree.left, getVal)[Symbol.iterator]();\r\n                item = iter_1.next();\r\n                _a.label = 1;\r\n            case 1:\r\n                if (!!item.done) return [3 /*break*/, 4];\r\n                return [4 /*yield*/, item.value];\r\n            case 2:\r\n                _a.sent();\r\n                _a.label = 3;\r\n            case 3:\r\n                item = iter_1.next();\r\n                return [3 /*break*/, 1];\r\n            case 4: return [4 /*yield*/, getVal(tree.value)];\r\n            case 5:\r\n                _a.sent();\r\n                if (!tree.right) return [3 /*break*/, 9];\r\n                iter_2 = iterTree(tree.right, getVal)[Symbol.iterator]();\r\n                item = iter_2.next();\r\n                _a.label = 6;\r\n            case 6:\r\n                if (!!item.done) return [3 /*break*/, 9];\r\n                return [4 /*yield*/, item.value];\r\n            case 7:\r\n                _a.sent();\r\n                _a.label = 8;\r\n            case 8:\r\n                item = iter_2.next();\r\n                return [3 /*break*/, 6];\r\n            case 9: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nvar ImmuMap = /** @class */ (function () {\r\n    function ImmuMap(entries, hash) {\r\n        if (hash === void 0) { hash = utils_1.defaultHash; }\r\n        var _this = this;\r\n        this._tree = null;\r\n        this._size = 0;\r\n        this._hash = hash;\r\n        if (entries) {\r\n            utils_1.iter(entries, function (_a) {\r\n                var k = _a[0], v = _a[1];\r\n                var _b = add(k, v, _this._tree, hash), status = _b[0], tree = _b[1];\r\n                _this._tree = tree;\r\n                if (status === AddStatus.added) {\r\n                    _this._size++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    Object.defineProperty(ImmuMap.prototype, \"size\", {\r\n        get: function () {\r\n            return this._size;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ImmuMap.prototype[Symbol.iterator] = function () {\r\n        return this.entries();\r\n    };\r\n    ImmuMap.prototype.forEach = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        utils_1.iter(this.entries(), function (_a) {\r\n            var key = _a[0], value = _a[1];\r\n            return callbackfn.call(thisArg, value, key, _this);\r\n        });\r\n    };\r\n    ImmuMap.prototype.get = function (key) {\r\n        return get(key, this._tree, this._hash);\r\n    };\r\n    ImmuMap.prototype.has = function (key) {\r\n        return mem(key, this._tree, this._hash);\r\n    };\r\n    ImmuMap.prototype.clear = function () {\r\n        return new ImmuMap();\r\n    };\r\n    ImmuMap.prototype.set = function (key, value) {\r\n        var _a = add(key, value, this._tree, this._hash), status = _a[0], tree = _a[1];\r\n        if (status !== AddStatus.none) {\r\n            var map = new ImmuMap();\r\n            map._tree = tree;\r\n            map._size = this._size;\r\n            if (status === AddStatus.added) {\r\n                map._size++;\r\n            }\r\n            return map;\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    };\r\n    ImmuMap.prototype.delete = function (key) {\r\n        var _a = remove(key, this._tree, this._hash), removed = _a[0], tree = _a[1];\r\n        if (removed) {\r\n            var map = new ImmuMap();\r\n            map._tree = tree;\r\n            map._size = this._size - 1;\r\n            return map;\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    };\r\n    ImmuMap.prototype.keys = function () {\r\n        return iterTree(this._tree, function (v) { return v[0]; });\r\n    };\r\n    ImmuMap.prototype.values = function () {\r\n        return iterTree(this._tree, function (v) { return v[1]; });\r\n    };\r\n    ImmuMap.prototype.entries = function () {\r\n        return iterTree(this._tree, function (v) { return v; });\r\n    };\r\n    ImmuMap.prototype.toJSON = function () {\r\n        var obj = {};\r\n        utils_1.iter(this.entries(), function (_a) {\r\n            var k = _a[0], v = _a[1];\r\n            if (typeof k !== 'string' && typeof k !== 'number') {\r\n                utils_2.error('map.toJSON failed, key: ', k, 'value:', v);\r\n                throw new TypeError(\"map.toJSON requires map's key to be number or string, but got \" + k);\r\n            }\r\n            obj[String(k)] = v;\r\n        });\r\n        return obj;\r\n    };\r\n    return ImmuMap;\r\n}());\r\nexports.default = ImmuMap;\r\n\n\n/***/ }),\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar list_1 = __webpack_require__(8);\r\nexports.ImmuList = list_1.default;\r\nvar map_1 = __webpack_require__(2);\r\nexports.ImmuMap = map_1.default;\r\nvar set_1 = __webpack_require__(10);\r\nexports.ImmuSet = set_1.default;\r\nexports.default = { ImmuList: list_1.default, ImmuMap: map_1.default, ImmuSet: set_1.default };\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(1);\r\nvar List = __webpack_require__(9);\r\nexports.List = List;\r\nfunction iteri(len) {\r\n    var i;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                i = 0;\r\n                _a.label = 1;\r\n            case 1:\r\n                if (!(i < len)) return [3 /*break*/, 4];\r\n                return [4 /*yield*/, i];\r\n            case 2:\r\n                _a.sent();\r\n                _a.label = 3;\r\n            case 3:\r\n                i++;\r\n                return [3 /*break*/, 1];\r\n            case 4: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nvar ImmuList = /** @class */ (function () {\r\n    function ImmuList(values) {\r\n        if (values) {\r\n            this._list = List.fromArray(values);\r\n        }\r\n        else {\r\n            this._list = List.empty();\r\n        }\r\n    }\r\n    Object.defineProperty(ImmuList.prototype, \"length\", {\r\n        get: function () {\r\n            return this._list.length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ImmuList.prototype.toString = function () {\r\n        return 'ImmuList [' + List.toArray(this._list).toString() + ']';\r\n    };\r\n    ImmuList.prototype.toLocaleString = function () {\r\n        return 'ImmuList [' + List.toArray(this._list).toLocaleString() + ']';\r\n    };\r\n    ImmuList.prototype.get = function (i) {\r\n        return List.nth(i, this._list);\r\n    };\r\n    ImmuList.prototype.set = function (i, val) {\r\n        var list = this._list;\r\n        if (i < 0 || i >= list.length) {\r\n            console.error(\"index out of range (0, \" + this._list.length + \"), this would silent ignored\");\r\n        }\r\n        list = List.update(i, val, this._list);\r\n        return this._new(list);\r\n    };\r\n    ImmuList.prototype.remove = function (from, amount) {\r\n        if (amount === void 0) { amount = 1; }\r\n        var list = List.remove(from, amount, this._list);\r\n        return this._new(list);\r\n    };\r\n    ImmuList.prototype.includes = function (item) {\r\n        return List.includes(item, this._list);\r\n    };\r\n    ImmuList.prototype.append = function (item) {\r\n        return this._new(List.append(item, this._list));\r\n    };\r\n    ImmuList.prototype.prepend = function (item) {\r\n        return this._new(List.prepend(item, this._list));\r\n    };\r\n    ImmuList.prototype.first = function () {\r\n        return List.first(this._list);\r\n    };\r\n    ImmuList.prototype.last = function () {\r\n        return List.last(this._list);\r\n    };\r\n    ImmuList.prototype.tail = function () {\r\n        return this._new(List.tail(this._list));\r\n    };\r\n    ImmuList.prototype.edit = function (cb) {\r\n        return this._new(cb(this._list, List));\r\n    };\r\n    ImmuList.prototype.editWithAny = function (cb) {\r\n        return cb(this._list, List);\r\n    };\r\n    ImmuList.prototype.toArray = function () {\r\n        return List.toArray(this._list);\r\n    };\r\n    ImmuList.prototype.toJSON = function () {\r\n        return this.toArray();\r\n    };\r\n    ImmuList.prototype.concat = function () {\r\n        var items = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            items[_i] = arguments[_i];\r\n        }\r\n        var list = this._list;\r\n        utils_1.iter(items, function (item) {\r\n            if (item instanceof ImmuList) {\r\n                list = List.concat(list, item._list);\r\n            }\r\n            else if (item instanceof Array) {\r\n                list = item.reduce(function (l, i) { return List.append(i, l); }, list);\r\n            }\r\n            else {\r\n                list = List.append(item, list);\r\n            }\r\n        });\r\n        if (list.length > this._list.length) {\r\n            return this._new(list);\r\n        }\r\n        return this;\r\n    };\r\n    ImmuList.prototype.join = function (separator) {\r\n        var sep = separator || ',';\r\n        return List.join(sep, this._list);\r\n    };\r\n    ImmuList.prototype.slice = function (start, end) {\r\n        var newList = List.slice(start || 0, end || this._list.length, this._list);\r\n        if (newList.length !== this._list.length) {\r\n            return this._new(newList);\r\n        }\r\n        return this;\r\n    };\r\n    ImmuList.prototype.indexOf = function (searchElement, fromIndex) {\r\n        var list = this._list;\r\n        if (fromIndex) {\r\n            list = List.slice(fromIndex, this._list.length, list);\r\n        }\r\n        return List.indexOf(searchElement, list);\r\n    };\r\n    ImmuList.prototype.every = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.every(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n    };\r\n    ImmuList.prototype.some = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.some(function (v) {\r\n            return callbackfn.call(thisArg, v, i++, _this);\r\n        }, this._list);\r\n    };\r\n    ImmuList.prototype.forEach = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        List.foldl(function (_, v) { return (callbackfn.call(thisArg, v, i++, _this), undefined); }, undefined, this._list);\r\n    };\r\n    ImmuList.prototype.map = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        var list = List.map(function (v) { return callbackfn.call(thisArg, v, i++, _this); }, this._list);\r\n        return this._new(list);\r\n    };\r\n    ImmuList.prototype.filter = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        var list = List.filter(function (v) { return callbackfn.call(thisArg, v, i++, _this); }, this._list);\r\n        if (list.length !== this._list.length) {\r\n            return this._new(list);\r\n        }\r\n        return this;\r\n    };\r\n    ImmuList.prototype.reduce = function (callbackfn, initialValue, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.foldl(function (acc, v) { return callbackfn.call(thisArg, acc, v, i++, _this); }, initialValue, this._list);\r\n    };\r\n    ImmuList.prototype.reduceRight = function (callbackfn, initialValue, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.foldr(function (v, acc) { return callbackfn.call(thisArg, acc, v, i++, _this); }, initialValue, this._list);\r\n    };\r\n    ImmuList.prototype[Symbol.iterator] = function () {\r\n        return utils_1.iterMap(this._list, function (v) { return v; });\r\n    };\r\n    ImmuList.prototype.entries = function () {\r\n        var i = 0;\r\n        return utils_1.iterMap(this._list, function (v) { return [i++, v]; });\r\n    };\r\n    ImmuList.prototype.keys = function () {\r\n        return iteri(this._list.length);\r\n    };\r\n    ImmuList.prototype.values = function () {\r\n        return utils_1.iterMap(this._list, function (v) { return v; });\r\n    };\r\n    ImmuList.prototype.find = function (predicate, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.find(function (v) { return predicate.call(thisArg, v, i++, _this); }, this._list);\r\n    };\r\n    ImmuList.prototype.findIndex = function (predicate, thisArg) {\r\n        var _this = this;\r\n        var i = 0;\r\n        return List.findIndex(function (v) { return predicate.call(thisArg, v, i++, _this); }, this._list);\r\n    };\r\n    ImmuList.prototype._new = function (list) {\r\n        var newImmuList = new ImmuList();\r\n        newImmuList._list = list;\r\n        return newImmuList;\r\n    };\r\n    return ImmuList;\r\n}());\r\nexports.default = ImmuList;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar branchingFactor = 32;\nvar branchBits = 5;\nvar mask = 31;\nvar elementEquals = function (a, b) {\n    return a === b;\n};\nfunction setEquals(equals) {\n    elementEquals = equals;\n}\nexports.setEquals = setEquals;\nfunction createPath(depth, value) {\n    var current = value;\n    for (var i = 0; i < depth; ++i) {\n        current = new Node(undefined, [current]);\n    }\n    return current;\n}\n// Array helper functions\nfunction copyArray(source) {\n    var array = [];\n    for (var i = 0; i < source.length; ++i) {\n        array[i] = source[i];\n    }\n    return array;\n}\nfunction pushElements(source, target, offset, amount) {\n    for (var i = offset; i < offset + amount; ++i) {\n        target.push(source[i]);\n    }\n}\nfunction copyIndices(source, sourceStart, target, targetStart, length) {\n    for (var i = 0; i < length; ++i) {\n        target[targetStart + i] = source[sourceStart + i];\n    }\n}\nfunction arrayPrepend(value, array) {\n    var newLength = array.length + 1;\n    var result = new Array(newLength);\n    result[0] = value;\n    for (var i = 1; i < newLength; ++i) {\n        result[i] = array[i - 1];\n    }\n    return result;\n}\n/**\n * Prepends an element to a node\n */\nfunction nodePrepend(value, size, node) {\n    var array = arrayPrepend(value, node.array);\n    var sizes = undefined;\n    if (node.sizes !== undefined) {\n        sizes = new Array(node.sizes.length + 1);\n        sizes[0] = size;\n        for (var i = 0; i < node.sizes.length; ++i) {\n            sizes[i + 1] = node.sizes[i] + size;\n        }\n    }\n    return new Node(sizes, array);\n}\n/**\n * Create a reverse _copy_ of an array.\n */\nfunction reverseArray(array) {\n    return array.slice().reverse();\n}\nfunction arrayFirst(array) {\n    return array[0];\n}\nfunction arrayLast(array) {\n    return array[array.length - 1];\n}\nfunction updateNode(node, depth, index, offset, value) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    if (node.sizes !== undefined) {\n        while (node.sizes[path] <= index) {\n            path++;\n        }\n        var traversed = path === 0 ? 0 : node.sizes[path - 1];\n        index -= traversed;\n    }\n    var array;\n    if (path < 0) {\n        // TOOD: Once `prepend` no longer uses `update` this should be removed\n        array = arrayPrepend(createPath(depth, value), node.array);\n    }\n    else {\n        array = copyArray(node.array);\n        if (depth === 0) {\n            array[path] = value;\n        }\n        else {\n            array[path] = updateNode(array[path], depth - 1, index, path === 0 ? offset : 0, value);\n        }\n    }\n    return new Node(node.sizes, array);\n}\nvar Node = /** @class */ (function () {\n    function Node(sizes, array) {\n        this.sizes = sizes;\n        this.array = array;\n    }\n    return Node;\n}());\nexports.Node = Node;\nfunction nodeNthDense(node, depth, index, offset) {\n    index += offset;\n    var path;\n    var current = node;\n    for (; depth >= 0; --depth) {\n        path =\n            ((index >> (depth * branchBits)) & mask) -\n                ((offset >> (depth * branchBits)) & mask);\n        if (path !== 0) {\n            offset = 0;\n        }\n        current = current.array[path];\n    }\n    return current;\n}\nfunction nodeNth(node, depth, index) {\n    var path;\n    var current = node;\n    while (current.sizes !== undefined) {\n        path = (index >> (depth * branchBits)) & mask;\n        while (current.sizes[path] <= index) {\n            path++;\n        }\n        var traversed = path === 0 ? 0 : current.sizes[path - 1];\n        index -= traversed;\n        depth--;\n        current = current.array[path];\n    }\n    return nodeNthDense(current, depth, index, 0);\n}\nfunction cloneNode(_a) {\n    var sizes = _a.sizes, array = _a.array;\n    return new Node(sizes === undefined ? undefined : copyArray(sizes), copyArray(array));\n}\nfunction suffixToNode(suffix) {\n    // FIXME: should take size and copy\n    return new Node(undefined, suffix);\n}\nfunction prefixToNode(prefix) {\n    // FIXME: should take size and copy\n    return new Node(undefined, prefix.reverse());\n}\nfunction setSizes(node, height) {\n    var sum = 0;\n    var sizeTable = [];\n    for (var i = 0; i < node.array.length; ++i) {\n        sum += sizeOfSubtree(node.array[i], height - 1);\n        sizeTable[i] = sum;\n    }\n    node.sizes = sizeTable;\n    return node;\n}\n/**\n * Returns the number of elements stored in the node.\n */\nfunction sizeOfSubtree(node, height) {\n    if (height !== 0) {\n        if (node.sizes !== undefined) {\n            return arrayLast(node.sizes);\n        }\n        else {\n            // the node is leftwise dense so all all but the last child are full\n            var lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);\n            return ((node.array.length - 1) << (height * branchBits)) + lastSize;\n        }\n    }\n    else {\n        return node.array.length;\n    }\n}\n// This array should not be mutated. Thus a dummy element is placed in\n// it. Thus the affix will not be owned and thus not mutated.\nvar emptyAffix = [0];\nfunction affixPush(a, array, length) {\n    if (array.length === length) {\n        array.push(a);\n        return array;\n    }\n    else {\n        var newArray = [];\n        copyIndices(array, 0, newArray, 0, length);\n        newArray.push(a);\n        return newArray;\n    }\n}\n// We store a bit field in list. From right to left, the first five\n// bits are suffix length, the next five are prefix length and the\n// rest is depth. The functions below are for working with the bits in\n// a sane way.\nvar affixBits = 6;\nvar affixMask = 63;\nfunction getSuffixSize(l) {\n    return l.bits & affixMask;\n}\nfunction getPrefixSize(l) {\n    return (l.bits >> affixBits) & affixMask;\n}\nfunction getDepth(l) {\n    return l.bits >> (affixBits * 2);\n}\nfunction setPrefix(size, bits) {\n    return (size << affixBits) | (bits & ~(affixMask << affixBits));\n}\nfunction setSuffix(size, bits) {\n    return size | (bits & ~affixMask);\n}\nfunction setDepth(depth, bits) {\n    return ((depth << (affixBits * 2)) | (bits & (affixMask | (affixMask << affixBits))));\n}\nfunction incrementPrefix(bits) {\n    return bits + (1 << affixBits);\n}\nfunction incrementSuffix(bits) {\n    return bits + 1;\n}\nfunction incrementDepth(bits) {\n    return bits + (1 << (affixBits * 2));\n}\n// function decrementDepth(bits: number): number {\n//   return bits - (1 << (affixBits * 2));\n// }\nfunction createBits(depth, prefixSize, suffixSize) {\n    return (depth << (affixBits * 2)) | (prefixSize << affixBits) | suffixSize;\n}\n/*\n * Invariants that any list `l` should satisfy\n *\n * 1. If `l.root !== undefined` then `getSuffixSize(l) !== 0` and\n *   `getPrefixSize(l) !== 0`. The invariant ensures that `first` and\n *   `last` never have to look in the root and that they therefore\n *   take O(1) time.\n * 2. If a tree or sub-tree does not have a size-table then all leaf\n      nodes in the tree are of size 32.\n */\nvar List = /** @class */ (function () {\n    function List(bits, offset, length, root, suffix, prefix) {\n        this.bits = bits;\n        this.offset = offset;\n        this.length = length;\n        this.root = root;\n        this.suffix = suffix;\n        this.prefix = prefix;\n    }\n    List.prototype.space = function () {\n        return (Math.pow(branchingFactor, (getDepth(this) + 1)) -\n            (this.length - getSuffixSize(this) - getPrefixSize(this) + this.offset));\n    };\n    List.prototype[Symbol.iterator] = function () {\n        return new ListIterator(this);\n    };\n    List.prototype[\"fantasy-land/equals\"] = function (l) {\n        return equals(this, l);\n    };\n    List.prototype[\"fantasy-land/map\"] = function (f) {\n        return map(f, this);\n    };\n    List.prototype[\"fantasy-land/filter\"] = function (predicate) {\n        return filter(predicate, this);\n    };\n    List.prototype[\"fantasy-land/empty\"] = function () {\n        return empty();\n    };\n    List.prototype[\"fantasy-land/concat\"] = function (right) {\n        return concat(this, right);\n    };\n    List.prototype[\"fantasy-land/reduce\"] = function (f, initial) {\n        return foldl(f, initial, this);\n    };\n    List.prototype.append = function (value) {\n        return append(value, this);\n    };\n    List.prototype.nth = function (index) {\n        return nth(index, this);\n    };\n    return List;\n}());\nexports.List = List;\nfunction cloneList(l) {\n    return new List(l.bits, l.offset, l.length, l.root, l.suffix, l.prefix);\n}\nvar iteratorDone = { done: true, value: undefined };\nvar ListIterator = /** @class */ (function () {\n    function ListIterator(list) {\n        this.list = list;\n        this.stack = [];\n        this.indices = [];\n        this.prefixLeft = getPrefixSize(list);\n        if (list.root !== undefined) {\n            var currentNode = list.root.array;\n            var depth = getDepth(list);\n            for (var i = 0; i < depth + 1; ++i) {\n                this.stack.push(currentNode);\n                this.indices.push(0);\n                currentNode = arrayFirst(currentNode).array;\n            }\n            this.indices[this.indices.length - 1] = -1;\n        }\n        else {\n            this.indices.push(-1);\n        }\n    }\n    ListIterator.prototype.goUp = function () {\n        this.stack.pop();\n        this.indices.pop();\n    };\n    ListIterator.prototype.remaining = function () {\n        var node = arrayLast(this.stack);\n        var idx = arrayLast(this.indices);\n        return node.length - idx - 1;\n    };\n    ListIterator.prototype.incrementIndex = function () {\n        return ++this.indices[this.indices.length - 1];\n    };\n    ListIterator.prototype.nextInTree = function () {\n        while (this.remaining() === 0) {\n            this.goUp();\n            if (this.stack.length === 0) {\n                return;\n            }\n        }\n        this.incrementIndex();\n        var depth = getDepth(this.list);\n        for (var i = this.indices.length - 1; i < depth; ++i) {\n            this.stack.push(arrayLast(this.stack)[arrayLast(this.indices)].array);\n            this.indices.push(0);\n        }\n    };\n    ListIterator.prototype.next = function () {\n        if (this.prefixLeft > 0) {\n            --this.prefixLeft;\n            return { done: false, value: this.list.prefix[this.prefixLeft] };\n        }\n        else if (this.stack.length !== 0) {\n            this.nextInTree();\n            if (this.stack.length !== 0) {\n                var leaf = arrayLast(this.stack);\n                var idx = arrayLast(this.indices);\n                var value = leaf[idx];\n                return { done: false, value: value };\n            }\n            else {\n                this.indices.push(-1);\n            }\n        }\n        var suffixSize = getSuffixSize(this.list);\n        if (this.indices[0] < suffixSize - 1) {\n            var idx = this.incrementIndex();\n            return { done: false, value: this.list.suffix[idx] };\n        }\n        return iteratorDone;\n    };\n    return ListIterator;\n}());\n// prepend & append\nfunction prepend(value, l) {\n    var prefixSize = getPrefixSize(l);\n    if (prefixSize < 32) {\n        return new List(incrementPrefix(l.bits), l.offset, l.length + 1, l.root, l.suffix, affixPush(value, l.prefix, prefixSize));\n    }\n    else {\n        var newList = cloneList(l);\n        prependNodeToTree(newList, reverseArray(l.prefix));\n        var newPrefix = [value];\n        newList.prefix = newPrefix;\n        newList.length++;\n        newList.bits = setPrefix(1, newList.bits);\n        return newList;\n    }\n}\nexports.prepend = prepend;\n/**\n * Traverses down the left edge of the tree and copies k nodes.\n * Returns the last copied node.\n * @param l\n * @param k The number of nodes to copy. Will always be at least 1.\n * @param leafSize The number of elements in the leaf that will be\n * inserted.\n */\nfunction copyLeft(l, k, leafSize) {\n    var currentNode = cloneNode(l.root); // copy root\n    l.root = currentNode; // install copy of root\n    for (var i = 1; i < k; ++i) {\n        var index = 0; // go left\n        if (currentNode.sizes !== undefined) {\n            for (var i_1 = 0; i_1 < currentNode.sizes.length; ++i_1) {\n                currentNode.sizes[i_1] += leafSize;\n            }\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        // Install the copied node\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    return currentNode;\n}\nfunction prependSizes(n, sizes) {\n    if (sizes === undefined) {\n        return undefined;\n    }\n    else {\n        var newSizes = new Array(sizes.length + 1);\n        newSizes[0] = n;\n        for (var i = 0; i < sizes.length; ++i) {\n            newSizes[i + 1] = sizes[i] + n;\n        }\n        return newSizes;\n    }\n}\n/**\n * Prepends a node to a tree. Either by shifting the nodes in the root\n * left or by increasing the height\n */\nfunction prependTopTree(l, depth, node) {\n    var newOffset;\n    if (l.root.array.length < branchingFactor) {\n        // There is space in the root\n        newOffset = Math.pow(32, depth) - 32;\n        l.root = new Node(prependSizes(32, l.root.sizes), arrayPrepend(createPath(depth - 1, node), l.root.array));\n    }\n    else {\n        // We need to create a new root\n        l.bits = incrementDepth(l.bits);\n        var sizes = l.root.sizes === undefined\n            ? undefined\n            : [32, arrayLast(l.root.sizes) + 32];\n        newOffset = depth === 0 ? 0 : Math.pow(32, (depth + 1)) - 32;\n        l.root = new Node(sizes, [createPath(depth, node), l.root]);\n    }\n    return newOffset;\n}\n/**\n * Takes a RRB-tree and a node tail. It then prepends the node to the\n * tree.\n * @param l The subject for prepending. `l` will be mutated. Nodes in\n * the tree will _not_ be mutated.\n * @param node The node that should be prepended to the tree.\n */\nfunction prependNodeToTree(l, array) {\n    if (l.root === undefined) {\n        if (getSuffixSize(l) === 0) {\n            // ensure invariant 1\n            l.bits = setSuffix(array.length, l.bits);\n            l.suffix = array;\n        }\n        else {\n            l.root = new Node(undefined, array);\n        }\n        return l;\n    }\n    else {\n        var node = new Node(undefined, array);\n        var depth = getDepth(l);\n        var newOffset = 0;\n        if (l.root.sizes === undefined) {\n            if (l.offset !== 0) {\n                newOffset = l.offset - branchingFactor;\n                l.root = prependDense(l.root, depth - 1, (l.offset - 1) >> 5, l.offset >> 5, node);\n            }\n            else {\n                // in this case we can be sure that the is not room in the tree\n                // for the new node\n                newOffset = prependTopTree(l, depth, node);\n            }\n        }\n        else {\n            // represents how many nodes _with size-tables_ that we should copy.\n            var copyableCount = 0;\n            // go down while there is size tables\n            var nodesTraversed = 0;\n            var currentNode = l.root;\n            while (currentNode.sizes !== undefined && nodesTraversed < depth) {\n                ++nodesTraversed;\n                if (currentNode.array.length < 32) {\n                    // there is room if offset is > 0 or if the first node does not\n                    // contain as many nodes as it possibly can\n                    copyableCount = nodesTraversed;\n                }\n                currentNode = currentNode.array[0];\n            }\n            if (l.offset !== 0) {\n                var copiedNode = copyLeft(l, nodesTraversed, 32);\n                for (var i = 0; i < copiedNode.sizes.length; ++i) {\n                    copiedNode.sizes[i] += branchingFactor;\n                }\n                copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed - 1, (l.offset - 1) >> 5, l.offset >> 5, node);\n                l.offset = l.offset - branchingFactor;\n                return l;\n            }\n            else {\n                if (copyableCount === 0) {\n                    l.offset = prependTopTree(l, depth, node);\n                }\n                else {\n                    var parent_1;\n                    var prependableNode = void 0;\n                    // Copy the part of the path with size tables\n                    if (copyableCount > 1) {\n                        parent_1 = copyLeft(l, copyableCount - 1, 32);\n                        prependableNode = parent_1.array[0];\n                    }\n                    else {\n                        parent_1 = undefined;\n                        prependableNode = l.root;\n                    }\n                    var path = createPath(depth - copyableCount, node);\n                    // add offset\n                    l.offset = Math.pow(32, (depth - copyableCount + 1)) - 32;\n                    var prepended = nodePrepend(path, 32, prependableNode);\n                    if (parent_1 === undefined) {\n                        l.root = prepended;\n                    }\n                    else {\n                        parent_1.array[0] = prepended;\n                    }\n                }\n                return l;\n            }\n        }\n        l.offset = newOffset;\n        return l;\n    }\n}\nfunction prependDense(node, depth, index, offset, value) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    var array;\n    if (path < 0) {\n        array = arrayPrepend(createPath(depth, value), node.array);\n    }\n    else {\n        array = copyArray(node.array);\n        if (depth === 0) {\n            array[path] = value;\n        }\n        else {\n            array[path] = updateNode(array[path], depth - 1, index, path === 0 ? offset : 0, value);\n        }\n    }\n    return new Node(node.sizes, array);\n}\nfunction append(value, l) {\n    var suffixSize = getSuffixSize(l);\n    if (suffixSize < 32) {\n        return new List(incrementSuffix(l.bits), l.offset, l.length + 1, l.root, affixPush(value, l.suffix, suffixSize), l.prefix);\n    }\n    var newSuffix = [value];\n    var suffixNode = suffixToNode(l.suffix);\n    var newList = cloneList(l);\n    appendNodeToTree(newList, suffixNode);\n    newList.suffix = newSuffix;\n    newList.length++;\n    newList.bits = setSuffix(1, newList.bits);\n    return newList;\n}\nexports.append = append;\nfunction list() {\n    var elements = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        elements[_i] = arguments[_i];\n    }\n    var l = empty();\n    for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {\n        var element = elements_1[_a];\n        l = append(element, l);\n    }\n    return l;\n}\nexports.list = list;\nfunction pair(first, second) {\n    return new List(2, 0, 2, undefined, [first, second], emptyAffix);\n}\nexports.pair = pair;\nfunction empty() {\n    return new List(0, 0, 0, undefined, emptyAffix, emptyAffix);\n}\nexports.empty = empty;\nfunction repeat(value, times) {\n    var l = empty();\n    while (--times >= 0) {\n        l = append(value, l);\n    }\n    return l;\n}\nexports.repeat = repeat;\nfunction length(l) {\n    return l.length;\n}\nexports.length = length;\nfunction first(l) {\n    if (getPrefixSize(l) !== 0) {\n        return arrayLast(l.prefix);\n    }\n    else if (getSuffixSize(l) !== 0) {\n        return arrayFirst(l.suffix);\n    }\n}\nexports.first = first;\nfunction last(l) {\n    if (getSuffixSize(l) !== 0) {\n        return arrayLast(l.suffix);\n    }\n    else if (getPrefixSize(l) !== 0) {\n        return arrayFirst(l.prefix);\n    }\n}\nexports.last = last;\nfunction nth(index, l) {\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    var offset = l.offset;\n    if (index < prefixSize) {\n        return l.prefix[prefixSize - index - 1];\n    }\n    else if (index >= l.length - suffixSize) {\n        return l.suffix[index - (l.length - suffixSize)];\n    }\n    var depth = getDepth(l);\n    return l.root.sizes === undefined\n        ? nodeNthDense(l.root, depth, index - prefixSize, offset)\n        : nodeNth(l.root, depth, index - prefixSize);\n}\nexports.nth = nth;\n// map\nfunction mapArray(f, array) {\n    var result = new Array(array.length);\n    for (var i = 0; i < array.length; ++i) {\n        result[i] = f(array[i]);\n    }\n    return result;\n}\nfunction mapNode(f, node, depth) {\n    if (depth !== 0) {\n        var array = node.array;\n        var result = new Array(array.length);\n        for (var i = 0; i < array.length; ++i) {\n            result[i] = mapNode(f, array[i], depth - 1);\n        }\n        return new Node(node.sizes, result);\n    }\n    else {\n        return new Node(undefined, mapArray(f, node.array));\n    }\n}\nfunction mapAffix(f, suffix, length) {\n    var newSuffix = new Array(length);\n    for (var i = 0; i < length; ++i) {\n        newSuffix[i] = f(suffix[i]);\n    }\n    return newSuffix;\n}\nfunction map(f, l) {\n    return new List(l.bits, l.offset, l.length, l.root === undefined ? undefined : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)), mapAffix(f, l.prefix, getPrefixSize(l)));\n}\nexports.map = map;\nfunction pluck(key, l) {\n    return map(function (a) { return a[key]; }, l);\n}\nexports.pluck = pluck;\nfunction range(start, end) {\n    var list = empty();\n    for (var i = start; i < end; ++i) {\n        list = list.append(i);\n    }\n    return list;\n}\nexports.range = range;\n// fold\nfunction foldlSuffix(f, acc, array, length) {\n    for (var i = 0; i < length; ++i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlPrefix(f, acc, array, length) {\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(acc, array[i]);\n    }\n    return acc;\n}\nfunction foldlNode(f, acc, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlSuffix(f, acc, array, array.length);\n    }\n    for (var i = 0; i < array.length; ++i) {\n        acc = foldlNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nfunction foldl(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    initial = foldlPrefix(f, initial, l.prefix, prefixSize);\n    if (l.root !== undefined) {\n        initial = foldlNode(f, initial, l.root, getDepth(l));\n    }\n    return foldlSuffix(f, initial, l.suffix, suffixSize);\n}\nexports.foldl = foldl;\nexports.reduce = foldl;\nfunction filter(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? append(a, acc) : acc); }, empty(), l);\n}\nexports.filter = filter;\nfunction reject(predicate, l) {\n    return foldl(function (acc, a) { return (predicate(a) ? acc : append(a, acc)); }, empty(), l);\n}\nexports.reject = reject;\nfunction join(separator, l) {\n    return foldl(function (a, b) { return (a.length === 0 ? b : a + separator + b); }, \"\", l);\n}\nexports.join = join;\nfunction foldrSuffix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = length - 1; 0 <= i; --i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrPrefix(f, initial, array, length) {\n    var acc = initial;\n    for (var i = 0; i < length; ++i) {\n        acc = f(array[i], acc);\n    }\n    return acc;\n}\nfunction foldrNode(f, initial, _a, depth) {\n    var array = _a.array;\n    if (depth === 0) {\n        return foldrSuffix(f, initial, array, array.length);\n    }\n    var acc = initial;\n    for (var i = array.length - 1; 0 <= i; --i) {\n        acc = foldrNode(f, acc, array[i], depth - 1);\n    }\n    return acc;\n}\nfunction foldr(f, initial, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    var acc = foldrSuffix(f, initial, l.suffix, suffixSize);\n    if (l.root !== undefined) {\n        acc = foldrNode(f, acc, l.root, getDepth(l));\n    }\n    return foldrPrefix(f, acc, l.prefix, prefixSize);\n}\nexports.foldr = foldr;\nexports.reduceRight = foldr;\nfunction flatten(nested) {\n    return foldl(concat, empty(), nested);\n}\nexports.flatten = flatten;\nfunction foldlSuffixCb(cb, state, array, length) {\n    for (var i = 0; i < length && cb(array[i], state); ++i) { }\n    return i === length;\n}\nfunction foldlPrefixCb(cb, state, array, length) {\n    for (var i = length - 1; 0 <= i && cb(array[i], state); --i) { }\n    return i === -1;\n}\nfunction foldlNodeCb(cb, state, node, depth) {\n    var array = node.array;\n    if (depth === 0) {\n        return foldlSuffixCb(cb, state, array, array.length);\n    }\n    for (var i = 0; i < array.length && foldlNodeCb(cb, state, array[i], depth - 1); ++i) { }\n    return i === array.length;\n}\n/**\n * This function is a lot like a fold. But the reducer function is\n * supposed to mutate its state instead of returning it. Instead of\n * returning a new state it returns a boolean that tells wether or not\n * to continue the fold. `true` indicates that the folding should\n * continue.\n */\nfunction foldlCb(cb, state, l) {\n    var suffixSize = getSuffixSize(l);\n    var prefixSize = getPrefixSize(l);\n    if (foldlPrefixCb(cb, state, l.prefix, prefixSize)) {\n        if (l.root !== undefined) {\n            if (foldlNodeCb(cb, state, l.root, getDepth(l))) {\n                foldlSuffixCb(cb, state, l.suffix, suffixSize);\n            }\n        }\n        else {\n            foldlSuffixCb(cb, state, l.suffix, suffixSize);\n        }\n    }\n    return state;\n}\nfunction everyCb(value, state) {\n    return (state.result = state.predicate(value));\n}\nfunction every(predicate, l) {\n    return foldlCb(everyCb, { predicate: predicate, result: true }, l).result;\n}\nexports.every = every;\nexports.all = every;\nfunction someCb(value, state) {\n    return !(state.result = state.predicate(value));\n}\nfunction some(predicate, l) {\n    return foldlCb(someCb, { predicate: predicate, result: false }, l).result;\n}\nexports.some = some;\n// tslint:disable-next-line:variable-name\nexports.any = some;\nfunction none(predicate, l) {\n    return !some(predicate, l);\n}\nexports.none = none;\nfunction findCb(value, state) {\n    if (state.predicate(value)) {\n        state.result = value;\n        return false;\n    }\n    else {\n        return true;\n    }\n}\nfunction find(predicate, l) {\n    return foldlCb(findCb, { predicate: predicate, result: undefined }, l)\n        .result;\n}\nexports.find = find;\nfunction indexOfCb(value, state) {\n    ++state.index;\n    return !(state.found = elementEquals(value, state.element));\n}\nfunction indexOf(element, l) {\n    var _a = foldlCb(indexOfCb, { element: element, found: false, index: -1 }, l), found = _a.found, index = _a.index;\n    return found ? index : -1;\n}\nexports.indexOf = indexOf;\nfunction findIndexCb(value, state) {\n    ++state.index;\n    return !(state.found = state.predicate(value));\n}\nfunction findIndex(predicate, l) {\n    var _a = foldlCb(findIndexCb, { predicate: predicate, found: false, index: -1 }, l), found = _a.found, index = _a.index;\n    return found ? index : -1;\n}\nexports.findIndex = findIndex;\nvar containsState = {\n    element: undefined,\n    result: false\n};\nfunction containsCb(value, state) {\n    return !(state.result = value === state.element);\n}\nfunction includes(element, l) {\n    containsState.element = element;\n    containsState.result = false;\n    return foldlCb(containsCb, containsState, l).result;\n}\nexports.includes = includes;\nexports.contains = includes;\nvar equalsState = {\n    iterator: undefined,\n    equals: true\n};\nfunction equalsCb(value2, state) {\n    var value = state.iterator.next().value;\n    return (state.equals = elementEquals(value, value2));\n}\nfunction equals(firstList, secondList) {\n    if (firstList === secondList) {\n        return true;\n    }\n    else if (firstList.length !== secondList.length) {\n        return false;\n    }\n    else {\n        equalsState.iterator = secondList[Symbol.iterator]();\n        equalsState.equals = true;\n        return foldlCb(equalsCb, equalsState, firstList).equals;\n    }\n}\nexports.equals = equals;\n// concat\nvar eMax = 2;\nfunction createConcatPlan(array) {\n    var sizes = [];\n    var sum = 0;\n    for (var i_2 = 0; i_2 < array.length; ++i_2) {\n        sum += array[i_2].array.length; // FIXME: maybe only access array once\n        sizes[i_2] = array[i_2].array.length;\n    }\n    var optimalLength = Math.ceil(sum / branchingFactor);\n    var n = array.length;\n    var i = 0;\n    if (optimalLength + eMax >= n) {\n        return undefined; // no rebalancing needed\n    }\n    while (optimalLength + eMax < n) {\n        while (sizes[i] > branchingFactor - eMax / 2) {\n            // Skip nodes that are already sufficiently balanced\n            ++i;\n        }\n        // the node at this index is too short\n        var remaining = sizes[i]; // number of elements to re-distribute\n        do {\n            var size = Math.min(remaining + sizes[i + 1], branchingFactor);\n            sizes[i] = size;\n            remaining = remaining - (size - sizes[i + 1]);\n            ++i;\n        } while (remaining > 0);\n        // Shift nodes after\n        for (var j = i; j <= n - 1; ++j) {\n            sizes[j] = sizes[j + 1];\n        }\n        --i;\n        --n;\n    }\n    sizes.length = n;\n    return sizes;\n}\n/**\n * Combines the children of three nodes into an array. The last child\n * of `left` and the first child of `right is ignored as they've been\n * concatenated into `center`.\n */\nfunction concatNodeMerge(left, center, right) {\n    var array = [];\n    if (left !== undefined) {\n        for (var i = 0; i < left.array.length - 1; ++i) {\n            array.push(left.array[i]);\n        }\n    }\n    for (var i = 0; i < center.array.length; ++i) {\n        array.push(center.array[i]);\n    }\n    if (right !== undefined) {\n        for (var i = 1; i < right.array.length; ++i) {\n            array.push(right.array[i]);\n        }\n    }\n    return array;\n}\nfunction executeConcatPlan(merged, plan, height) {\n    var result = [];\n    var sourceIdx = 0; // the current node we're copying from\n    var offset = 0; // elements in source already used\n    for (var _i = 0, plan_1 = plan; _i < plan_1.length; _i++) {\n        var toMove = plan_1[_i];\n        var source = merged[sourceIdx].array;\n        if (toMove === source.length && offset === 0) {\n            // source matches target exactly, reuse source\n            result.push(merged[sourceIdx]);\n            ++sourceIdx;\n        }\n        else {\n            var node = new Node(undefined, []);\n            while (toMove > 0) {\n                var available = source.length - offset;\n                var itemsToCopy = Math.min(toMove, available);\n                pushElements(source, node.array, offset, itemsToCopy);\n                if (toMove >= available) {\n                    ++sourceIdx;\n                    source = merged[sourceIdx].array;\n                    offset = 0;\n                }\n                else {\n                    offset += itemsToCopy;\n                }\n                toMove -= itemsToCopy;\n            }\n            if (height > 1) {\n                // Set sizes on children unless they are leaf nodes\n                setSizes(node, height - 1);\n            }\n            result.push(node);\n        }\n    }\n    return result;\n}\n/**\n * Takes three nodes and returns a new node with the content of the\n * three nodes. Note: The returned node does not have its size table\n * set correctly. The caller must do that.\n */\nfunction rebalance(left, center, right, height, top) {\n    var merged = concatNodeMerge(left, center, right);\n    var plan = createConcatPlan(merged);\n    var balanced = plan !== undefined ? executeConcatPlan(merged, plan, height) : merged;\n    if (balanced.length <= branchingFactor) {\n        if (top === true) {\n            return new Node(undefined, balanced);\n        }\n        else {\n            // Return a single node with extra height for balancing at next\n            // level\n            return new Node(undefined, [\n                setSizes(new Node(undefined, balanced), height)\n            ]);\n        }\n    }\n    else {\n        return new Node(undefined, [\n            setSizes(new Node(undefined, balanced.slice(0, branchingFactor)), height),\n            setSizes(new Node(undefined, balanced.slice(branchingFactor)), height)\n        ]);\n    }\n}\nfunction concatSubTree(left, lDepth, right, rDepth, isTop) {\n    if (lDepth > rDepth) {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, right, rDepth, false);\n        return rebalance(left, c, undefined, lDepth, isTop);\n    }\n    else if (lDepth < rDepth) {\n        var c = concatSubTree(left, lDepth, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(undefined, c, right, rDepth, isTop);\n    }\n    else if (lDepth === 0) {\n        return new Node(undefined, [left, right]);\n    }\n    else {\n        var c = concatSubTree(arrayLast(left.array), lDepth - 1, arrayFirst(right.array), rDepth - 1, false);\n        return rebalance(left, c, right, lDepth, isTop);\n    }\n}\nfunction getHeight(node) {\n    if (node.array[0] instanceof Node) {\n        return 1 + getHeight(node.array[0]);\n    }\n    else {\n        return 0;\n    }\n}\n/**\n * Takes a RRB-tree and a node tail. It then appends the node to the\n * tree.\n * @param l The subject for appending. `l` will be mutated. Nodes in\n * the tree will _not_ be mutated.\n * @param node The node that should be appended to the tree.\n */\nfunction appendNodeToTree(l, node) {\n    if (l.root === undefined) {\n        // The old list has no content in tree, all content is in affixes\n        if (getPrefixSize(l) === 0) {\n            l.bits = setPrefix(node.array.length, l.bits);\n            l.prefix = reverseArray(node.array);\n        }\n        else {\n            l.root = node;\n        }\n        return l;\n    }\n    var depth = getDepth(l);\n    var index = l.length - 1 - getPrefixSize(l);\n    var nodesToCopy = 0;\n    var nodesVisited = 0;\n    var shift = depth * 5;\n    var currentNode = l.root;\n    if (Math.pow(32, (depth + 1)) < index) {\n        shift = 0; // there is no room\n        nodesVisited = depth;\n    }\n    while (shift > 5) {\n        var childIndex = void 0;\n        if (currentNode.sizes === undefined) {\n            // does not have size table\n            childIndex = (index >> shift) & mask;\n            index &= ~(mask << shift); // wipe just used bits\n        }\n        else {\n            childIndex = currentNode.array.length - 1;\n            index -= currentNode.sizes[childIndex - 1];\n        }\n        nodesVisited++;\n        if (childIndex < mask) {\n            // we are not going down the far right path, this implies that\n            // there is still room in the current node\n            nodesToCopy = nodesVisited;\n        }\n        currentNode = currentNode.array[childIndex];\n        if (currentNode === undefined) {\n            // This will only happened in a pvec subtree. The index does not\n            // exist so we'll have to create a new path from here on.\n            nodesToCopy = nodesVisited;\n            shift = 5; // Set shift to break out of the while-loop\n        }\n        shift -= 5;\n    }\n    if (shift !== 0) {\n        nodesVisited++;\n        if (currentNode.array.length < branchingFactor) {\n            // there is room in the found node\n            nodesToCopy = nodesVisited;\n        }\n    }\n    if (nodesToCopy === 0) {\n        // there was no room in the found node\n        var newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);\n        var newRoot = new Node(undefined, [l.root, newPath]);\n        l.root = newRoot;\n        l.bits = incrementDepth(l.bits);\n    }\n    else {\n        var copiedNode = copyFirstK(l, l, nodesToCopy, node.array.length);\n        var leaf = appendEmpty(copiedNode, depth - nodesToCopy);\n        leaf.array.push(node);\n    }\n    return l;\n}\n/**\n * Traverses down the right edge of the tree and copies k nodes\n * @param oldList\n * @param newList\n * @param k The number of nodes to copy. Will always be at least 1.\n * @param leafSize The number of elements in the leaf that will be inserted.\n */\nfunction copyFirstK(oldList, newList, k, leafSize) {\n    var currentNode = cloneNode(oldList.root); // copy root\n    newList.root = currentNode; // install root\n    for (var i = 1; i < k; ++i) {\n        var index = currentNode.array.length - 1;\n        if (currentNode.sizes !== undefined) {\n            currentNode.sizes[index] += leafSize;\n        }\n        var newNode = cloneNode(currentNode.array[index]);\n        // Install the copied node\n        currentNode.array[index] = newNode;\n        currentNode = newNode;\n    }\n    if (currentNode.sizes !== undefined) {\n        currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);\n    }\n    return currentNode;\n}\nfunction appendEmpty(node, depth) {\n    if (depth === 0) {\n        return node;\n    }\n    var current = new Node(undefined, []);\n    node.array.push(current);\n    for (var i = 1; i < depth; ++i) {\n        var newNode = new Node(undefined, []);\n        current.array[0] = newNode;\n        current = newNode;\n    }\n    return current;\n}\n/*\nfunction concatSuffix<A>(\n  left: A[], lSize: number, right: A[], rSize: number\n): A[] {\n  const newArray = new Array(lSize + rSize);\n  for (let i = 0; i < lSize; ++i) {\n    newArray[i] = left[i];\n  }\n  for (let i = 0; i < rSize; ++i) {\n    newArray[lSize + i] = right[i];\n  }\n  return newArray;\n}\n*/\nvar concatBuffer = new Array(3);\nfunction concatAffixes(left, right) {\n    // TODO: Try and find a neat way to reduce the LOC here\n    var nr = 0;\n    var arrIdx = 0;\n    var i = 0;\n    var length = getSuffixSize(left);\n    concatBuffer[nr] = [];\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx] = left.suffix[i];\n        if (++arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n    }\n    length = getPrefixSize(right);\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx] = right.prefix[right.prefix.length - 1 - i];\n        if (++arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n    }\n    length = getSuffixSize(right);\n    for (i = 0; i < length; ++i) {\n        concatBuffer[nr][arrIdx] = right.suffix[i];\n        if (++arrIdx === 32) {\n            arrIdx = 0;\n            ++nr;\n            concatBuffer[nr] = [];\n        }\n    }\n    return nr;\n}\nfunction concat(left, right) {\n    if (left.length === 0) {\n        return right;\n    }\n    else if (right.length === 0) {\n        return left;\n    }\n    var newSize = left.length + right.length;\n    var rightSuffixSize = getSuffixSize(right);\n    var newList = cloneList(left);\n    if (right.root === undefined) {\n        // right is nothing but a prefix and a suffix\n        var nrOfAffixes = concatAffixes(left, right);\n        for (var i = 0; i < nrOfAffixes; ++i) {\n            newList = appendNodeToTree(newList, new Node(undefined, concatBuffer[i]));\n            newList.length += concatBuffer[i].length;\n            // wipe pointer, otherwise it might end up keeping the array alive\n            concatBuffer[i] = undefined;\n        }\n        newList.length = newSize;\n        newList.suffix = concatBuffer[nrOfAffixes];\n        newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);\n        concatBuffer[nrOfAffixes] = undefined;\n        return newList;\n    }\n    else {\n        newList = appendNodeToTree(newList, suffixToNode(left.suffix));\n        newList.length += getSuffixSize(left);\n        newList = appendNodeToTree(newList, prefixToNode(right.prefix));\n        var newNode = concatSubTree(newList.root, getDepth(newList), right.root, getDepth(right), true);\n        var newDepth = getHeight(newNode);\n        setSizes(newNode, newDepth);\n        var bits = createBits(newDepth, getPrefixSize(newList), rightSuffixSize);\n        // FIXME: Return `newList` here\n        return new List(bits, 0, newSize, newNode, right.suffix, newList.prefix);\n    }\n}\nexports.concat = concat;\nfunction update(index, a, l) {\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    var newList = cloneList(l);\n    if (index < prefixSize) {\n        var newPrefix = copyArray(newList.prefix);\n        newPrefix[newPrefix.length - index - 1] = a;\n        newList.prefix = newPrefix;\n    }\n    else if (index >= l.length - suffixSize) {\n        var newSuffix = copyArray(newList.suffix);\n        newSuffix[index - (l.length - suffixSize)] = a;\n        newList.suffix = newSuffix;\n    }\n    else {\n        newList.root = updateNode(l.root, getDepth(l), index - prefixSize + l.offset, l.offset, a);\n    }\n    return newList;\n}\nexports.update = update;\nfunction adjust(f, index, l) {\n    return update(index, f(nth(index, l)), l);\n}\nexports.adjust = adjust;\n// slice and slice based functions\nvar newAffix;\nfunction sliceLeft(tree, depth, index, offset) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    if (depth === 0) {\n        newAffix = tree.array.slice(path).reverse();\n        // this leaf node is moved up as a suffix so there is nothing here\n        // after slicing\n        return undefined;\n    }\n    else {\n        // slice the child\n        var child = sliceLeft(tree.array[path], depth - 1, index, path === 0 ? offset : 0);\n        if (child === undefined) {\n            // there is nothing in the child after slicing so we don't include it\n            ++path;\n            if (path === tree.array.length) {\n                return undefined;\n            }\n        }\n        var array = tree.array.slice(path);\n        if (child !== undefined) {\n            array[0] = child;\n        }\n        return new Node(tree.sizes, array); // FIXME: handle the size table\n    }\n}\nfunction sliceRight(tree, depth, index, offset) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var path = ((index >> (depth * branchBits)) & mask) - curOffset;\n    if (depth === 0) {\n        newAffix = tree.array.slice(0, path + 1);\n        // this leaf node is moved up as a suffix so there is nothing here\n        // after slicing\n        return undefined;\n    }\n    else {\n        // slice the child, note that we subtract 1 then the radix lookup\n        // algorithm can find the last element that we want to include\n        // and sliceRight will do a slice that is inclusive on the index.\n        var child = sliceRight(tree.array[path], depth - 1, index, path === 0 ? offset : 0);\n        if (child === undefined) {\n            // there is nothing in the child after slicing so we don't include it\n            --path;\n            if (path === -1) {\n                return undefined;\n            }\n        }\n        // note that we add 1 to the path since we want the slice to be\n        // inclusive on the end index. Only at the leaf level do we want\n        // to do an exclusive slice.\n        var array = tree.array.slice(0, path + 1);\n        if (child !== undefined) {\n            array[array.length - 1] = child;\n        }\n        return new Node(tree.sizes, array); // FIXME: handle the size table\n    }\n}\nfunction sliceTreeList(from, to, tree, depth, offset, l) {\n    var curOffset = (offset >> (depth * branchBits)) & mask;\n    var pathLeft = ((from >> (depth * branchBits)) & mask) - curOffset;\n    var pathRight = ((to >> (depth * branchBits)) & mask) - curOffset;\n    if (depth === 0) {\n        // we are slicing a piece off a leaf node\n        l.prefix = emptyAffix;\n        l.suffix = tree.array.slice(pathLeft, pathRight + 1);\n        l.root = undefined;\n        l.bits = setSuffix(pathRight - pathLeft + 1, 0);\n        return l;\n    }\n    else if (pathLeft === pathRight) {\n        // Both ends are located in the same subtree, this means that we\n        // can reduce the height\n        // l.bits = decrementDepth(l.bits);\n        // return sliceTreeList(from, to, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);\n        var rec = sliceTreeList(from, to, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);\n        if (rec.root !== undefined) {\n            rec.root = new Node(undefined, [rec.root]);\n        }\n        return rec;\n    }\n    else {\n        var childLeft = sliceLeft(tree.array[pathLeft], depth - 1, from, pathLeft === 0 ? offset : 0);\n        l.bits = setPrefix(newAffix.length, l.bits);\n        l.prefix = newAffix;\n        var childRight = sliceRight(tree.array[pathRight], depth - 1, to, 0);\n        l.bits = setSuffix(newAffix.length, l.bits);\n        l.suffix = newAffix;\n        if (childLeft === undefined) {\n            ++pathLeft;\n        }\n        if (childRight === undefined) {\n            --pathRight;\n        }\n        if (pathLeft > pathRight) {\n            // there is no tree left\n            l.bits = setDepth(0, l.bits);\n            l.root = undefined;\n            // } else if (pathLeft === pathRight) {\n            // height can be reduced\n            // l.bits = decrementDepth(l.bits);\n            // l.root = childLeft === undefined ? childRight : childLeft;\n        }\n        else {\n            var array = tree.array.slice(pathLeft, pathRight + 1);\n            if (childLeft !== undefined) {\n                array[0] = childLeft;\n            }\n            if (childRight !== undefined) {\n                array[array.length - 1] = childRight;\n            }\n            l.root = new Node(tree.sizes, array);\n        }\n        return l;\n    }\n}\nfunction slice(from, to, l) {\n    var bits = l.bits, length = l.length;\n    to = Math.min(length, to);\n    // handle negative indices\n    if (from < 0) {\n        from = length + from;\n    }\n    if (to < 0) {\n        to = length + to;\n    }\n    if (to <= from || to <= 0 || length <= from) {\n        return empty();\n    }\n    // return list unchanged if we are slicing nothing off\n    if (from <= 0 && length <= to) {\n        return l;\n    }\n    var newLength = to - from;\n    var prefixSize = getPrefixSize(l);\n    var suffixSize = getSuffixSize(l);\n    // both indices lie in the prefix\n    if (to <= prefixSize) {\n        return new List(setPrefix(newLength, 0), 0, newLength, undefined, emptyAffix, l.prefix.slice(l.prefix.length - to, l.prefix.length - from));\n    }\n    var suffixStart = length - suffixSize;\n    // both indices lie in the suffix\n    if (suffixStart <= from) {\n        return new List(setSuffix(newLength, 0), 0, newLength, undefined, l.suffix.slice(from - suffixStart, to - suffixStart), emptyAffix);\n    }\n    var newList = cloneList(l);\n    // both indices lie in the tree\n    if (prefixSize <= from && to <= length - suffixSize) {\n        sliceTreeList(from - prefixSize + l.offset, to - prefixSize + l.offset - 1, l.root, getDepth(l), l.offset, newList);\n        if (newList.root !== undefined) {\n            newList.offset += from - prefixSize + getPrefixSize(newList);\n        }\n        newList.length = to - from;\n        return newList;\n    }\n    // we need to slice something off of the left\n    if (0 < from) {\n        if (from < prefixSize) {\n            // do a cheap slice by setting prefix length\n            bits = setPrefix(prefixSize - from, bits);\n        }\n        else {\n            // if we're here `to` can't lie in the tree, so we can set the\n            // root\n            newList.root = sliceLeft(newList.root, getDepth(l), from - prefixSize + l.offset, l.offset);\n            bits = setPrefix(newAffix.length, bits);\n            newList.offset += from - prefixSize + newAffix.length;\n            prefixSize = newAffix.length;\n            newList.prefix = newAffix;\n        }\n        newList.length -= from;\n    }\n    if (to < length) {\n        if (length - to < suffixSize) {\n            bits = setSuffix(suffixSize - (length - to), bits);\n        }\n        else {\n            newList.root = sliceRight(newList.root, getDepth(l), to - prefixSize + newList.offset - 1, newList.offset);\n            if (newList.root === undefined) {\n                bits = setDepth(0, bits);\n            }\n            bits = setSuffix(newAffix.length, bits);\n            newList.suffix = newAffix;\n        }\n        newList.length -= length - to;\n    }\n    newList.bits = bits;\n    return newList;\n}\nexports.slice = slice;\nfunction take(n, l) {\n    return slice(0, n, l);\n}\nexports.take = take;\nfunction findNotIndexCb(value, state) {\n    ++state.index;\n    return state.predicate(value);\n}\nfunction takeWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: -1 }, l).index;\n    return slice(0, index, l);\n}\nexports.takeWhile = takeWhile;\nfunction dropWhile(predicate, l) {\n    var index = foldlCb(findNotIndexCb, { predicate: predicate, index: -1 }, l).index;\n    return slice(index, l.length, l);\n}\nexports.dropWhile = dropWhile;\nfunction takeLast(n, l) {\n    return slice(l.length - n, l.length, l);\n}\nexports.takeLast = takeLast;\nfunction splitAt(index, l) {\n    return [slice(0, index, l), slice(index, l.length, l)];\n}\nexports.splitAt = splitAt;\nfunction remove(from, amount, l) {\n    return concat(slice(0, from, l), slice(from + amount, l.length, l));\n}\nexports.remove = remove;\nfunction drop(n, l) {\n    return slice(n, l.length, l);\n}\nexports.drop = drop;\nfunction dropLast(n, l) {\n    return slice(0, l.length - n, l);\n}\nexports.dropLast = dropLast;\nfunction pop(l) {\n    return slice(0, -1, l);\n}\nexports.pop = pop;\nexports.init = pop;\nfunction tail(l) {\n    return slice(1, l.length, l);\n}\nexports.tail = tail;\nfunction arrayPush(array, a) {\n    array.push(a);\n    return array;\n}\nfunction toArray(l) {\n    return foldl(arrayPush, [], l);\n}\nexports.toArray = toArray;\nfunction fromArray(array) {\n    var l = empty();\n    for (var i = 0; i < array.length; ++i) {\n        l = append(array[i], l);\n    }\n    return l;\n}\nexports.fromArray = fromArray;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar map_1 = __webpack_require__(2);\r\nvar utils_1 = __webpack_require__(1);\r\nexports.defaultHash = utils_1.defaultHash;\r\nvar ImmuSet = /** @class */ (function () {\r\n    function ImmuSet(values, hash) {\r\n        if (hash === void 0) { hash = utils_1.defaultHash; }\r\n        if (values) {\r\n            this._map = new map_1.default(utils_1.iterMap(values, function (v) { return [v, v]; }), hash);\r\n        }\r\n        else {\r\n            this._map = new map_1.default([], hash);\r\n        }\r\n    }\r\n    Object.defineProperty(ImmuSet.prototype, \"size\", {\r\n        get: function () {\r\n            return this._map.size;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ImmuSet.prototype[Symbol.iterator] = function () {\r\n        return this._map.keys();\r\n    };\r\n    ImmuSet.prototype.add = function (value) {\r\n        var map = this._map.set(value, value);\r\n        if (map.size > this._map.size) {\r\n            var newSet = new ImmuSet();\r\n            newSet._map = map;\r\n            return newSet;\r\n        }\r\n        return this;\r\n    };\r\n    ImmuSet.prototype.clear = function () {\r\n        return new ImmuSet();\r\n    };\r\n    ImmuSet.prototype.delete = function (value) {\r\n        var map = this._map.delete(value);\r\n        if (map.size < this._map.size) {\r\n            var newSet = new ImmuSet();\r\n            newSet._map = map;\r\n            return newSet;\r\n        }\r\n        return this;\r\n    };\r\n    ImmuSet.prototype.entries = function () {\r\n        return this._map.entries();\r\n    };\r\n    ImmuSet.prototype.keys = function () {\r\n        return this._map.keys();\r\n    };\r\n    ImmuSet.prototype.values = function () {\r\n        return this._map.values();\r\n    };\r\n    ImmuSet.prototype.toArray = function () {\r\n        var arr = [];\r\n        utils_1.iter(this.keys(), function (item) { return arr.push(item); });\r\n        return arr;\r\n    };\r\n    ImmuSet.prototype.toJSON = function () {\r\n        return this.toArray();\r\n    };\r\n    ImmuSet.prototype.forEach = function (callbackfn, thisArg) {\r\n        var _this = this;\r\n        this._map.forEach(function (v1, v2, _) { return callbackfn(v1, v2, _this); }, thisArg);\r\n    };\r\n    ImmuSet.prototype.has = function (value) {\r\n        return this._map.has(value);\r\n    };\r\n    return ImmuSet;\r\n}());\r\nexports.default = ImmuSet;\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// hydux.collections.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c62b0604a7717f54c7fa","\nexport const isSet = val => typeof val !== 'undefined' && val !== null\nexport const isFn = (fn): fn is Function => typeof fn === 'function'\nexport const isPojo = obj => !isSet(obj.constructor) || obj.constructor === Object\nexport const error = (...args) => console.error('[hydux-mutator]', ...args)\nexport const isObj = obj => typeof obj === 'object' && obj\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts","export function * iterMap<T, U>(list: Iterable<T>, cb: (a: T) => U) {\n  if (list instanceof Array) {\n    for (const item of list) {\n      yield cb(item)\n    }\n    return\n  }\n  const iter = list[Symbol.iterator]()\n  for (let item = iter.next(); !item.done; item = iter.next()) {\n    yield cb(item.value)\n  }\n}\n\nexport function iter<T>(list: Iterable<T>, cb: (a: T) => void) {\n  if (list instanceof Array) {\n    return list.forEach(cb)\n  }\n  const iter = list[Symbol.iterator]()\n  for (let item = iter.next(); !item.done; item = iter.next()) {\n    cb(item.value)\n  }\n}\n\nfunction getType(key: any) {\n  const t: string = Object.prototype.toString.call(key)\n  return t.slice(8, -1).toLowerCase()\n}\n\nlet objUid = 0\nlet objUidKey = typeof Symbol !== 'undefined' ? Symbol('_hmuid_') : '_hmuid_'\nlet objUidMap = typeof WeakMap !== 'undefined' ? new WeakMap<object, number>() : null\n\nexport type Hash = (v: any) => string\n\nexport function defaultHash(key: any): string {\n  switch (getType(key)) {\n    case 'undefined':\n    case 'null':\n    case 'boolean':\n    case 'number':\n    case 'regexp':\n      return key + ''\n\n    case 'date':\n      return '' + key.getTime()\n\n    case 'string':\n      return '' + key\n\n    case 'array':\n      return '' + (key as any[]).map(k => defaultHash(k)).join('')\n\n    default:\n      if (objUidMap) {\n        let uid = objUidMap.get(key)\n        if (!uid) {\n          uid = ++objUid\n          objUidMap.set(key, uid)\n        }\n        return '' + uid\n      }\n      // TODO: Don't use expandos when Object.defineProperty is not available?\n      if (!key.hasOwnProperty(objUidKey)) {\n        key[objUidKey] = ++objUid\n        hide(key, objUidKey)\n      }\n\n      return '' + key[objUidKey]\n  }\n}\n\nfunction hide(obj, prop) {\n  // Make non iterable if supported\n  if (Object.defineProperty) {\n    Object.defineProperty(obj, prop, { enumerable: false })\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/utils.ts","import { defaultHash, Hash, iterMap, iter } from './utils'\nimport { error } from '../utils'\nimport { IImmutableSetable } from '../types'\n\ninterface TreeNode<K, V> {\n  value: [K, V],\n  left: Tree<K, V>,\n  right: Tree<K, V>,\n  height: number,\n}\n\ntype Tree<K, V> = TreeNode<K, V> | null\n\nexport { defaultHash }\n\nfunction height<K, V>(t: Tree<K, V>) {\n  if (t) {\n    return t.height\n  } else {\n    return 0\n  }\n}\n\nfunction create<K, V>(left: Tree<K, V>, value: [K, V], right: Tree<K, V>): TreeNode<K, V> {\n  return {\n    value,\n    left,\n    right,\n    height: Math.max(height(left), height(right)) + 1,\n  }\n}\n\nfunction impossible(): never {\n  throw new Error('[hydux-mutator/map] imposible')\n}\n\nfunction balance<K, V>(left: Tree<K, V>, value: [K, V], right: Tree<K, V>): Tree<K, V> {\n  let leftHeight = height(left)\n  let rightHeit = height(right)\n  if (leftHeight > rightHeit + 2) {\n    if (!left) {\n      return impossible()\n    } else {\n      if (height(left.left) >= height(left.right)) {\n        return create(left.left, left.value, create(left.right, value, right))\n      } else if (!left.right) {\n        return impossible()\n      } else {\n        return create(create(left.left, left.value, left.right.left), left.right.value, create(left.right.right, value, right))\n      }\n    }\n  } else if (rightHeit > leftHeight + 2) {\n    if (!right) {\n      return impossible()\n    } else {\n      if (height(right.right) >= height(right.right)) {\n        return create(create(left, value, right.left), right.value, right.right)\n      } else if (!right.left) {\n        return impossible()\n      } else {\n        return create(create(left, value, right.left.left), right.left.value, create(right.left.right, right.value, right.right))\n      }\n    }\n  } else {\n    return create(left, value, right)\n  }\n}\n\nenum AddStatus {\n  none = 0,\n  added = 1,\n  updated = 2,\n}\n\nfunction add<K, V>(key: K, value: V, tree: Tree<K, V>, hash: (v: any) => string): [AddStatus, Tree<K, V>] {\n  if (tree) {\n    const newKeyHash = hash(key)\n    const [treeKey, treeValue] = tree.value\n    const rootKeyHash = hash(treeKey)\n    if (newKeyHash === rootKeyHash) {\n      if (treeValue === value) {\n        return [AddStatus.none, tree]\n      } else {\n        return [AddStatus.updated, create(tree.left, [key, value], tree.right)]\n      }\n    } else if (newKeyHash < rootKeyHash) {\n      const res = add(key, value, tree.left, hash)\n      return [res[0], balance(res[1], tree.value, tree.right)]\n    } else {\n      const res = add(key, value, tree.right, hash)\n      return [res[0], balance(tree.left, tree.value, res[1])]\n    }\n  } else {\n    return [AddStatus.added, create(null, [key, value], null)]\n  }\n}\n\nfunction minElt<K, V>(value: [K, V], tree: Tree<K, V>) {\n  if (!tree) {\n    return value\n  } else if (!tree.left) {\n    return tree.value\n  } else {\n    return minElt(tree.value, tree.left)\n  }\n}\n\nfunction removeMinElt<K, V>(left: Tree<K, V>, value: [K, V], right: Tree<K, V>) {\n  if (!left) {\n    return right\n  } else {\n    return balance(removeMinElt(left.left, left.value, left.right), value, right)\n  }\n}\n\nfunction internalMerge<K, V>(left: Tree<K, V>, right: Tree<K, V>) {\n  if (!left) {\n    return right\n  } else if (!right) {\n    return left\n  } else if (right) {\n    return balance(left, minElt(right.value, right), removeMinElt(right.left, right.value, right.right))\n  }\n  return impossible()\n}\n\nfunction remove<K, V>(key: K, tree: Tree<K, V>, hash: Hash): [boolean, Tree<K, V>] {\n  if (!tree) {\n    return [false, null]\n  } else {\n    let keyHash = hash(key)\n    let oldKeyHash = hash(tree.value[0])\n    if (keyHash === oldKeyHash) {\n      return [true, internalMerge(tree.left, tree.right)]\n    } else if (keyHash < oldKeyHash) {\n      const res = remove(key, tree.left, hash)\n      return [res[0], balance(res[1], tree.value, tree.right)]\n    } else {\n      const res = remove(key, tree.right, hash)\n      return [res[0], balance(tree.left, tree.value, res[1])]\n    }\n  }\n}\n\nfunction mem<K, V>(key: K, tree: Tree<K, V>, hash: Hash): boolean {\n  if (!tree) {\n    return false\n  }\n  let keyHash = hash(key)\n  let oldKeyHash = hash(tree.value[0])\n  return keyHash === oldKeyHash || mem(key, (keyHash < oldKeyHash) ? tree.left : tree.right, hash)\n}\nfunction get<K, V>(key: K, tree: Tree<K, V>, hash: Hash): V | undefined {\n  if (!tree) {\n    return void 0\n  }\n  let keyHash = hash(key)\n  let oldKeyHash = hash(tree.value[0])\n  if (keyHash === oldKeyHash) {\n    return tree.value[1]\n  }\n  return get(key, (keyHash < oldKeyHash) ? tree.left : tree.right, hash)\n}\n\nfunction unimplemented(): never {\n  throw new Error('unimplemented')\n}\n\nfunction * iterTree<K, V, T>(tree: Tree<K, V>, getVal: (v: [K, V]) => T): IterableIterator<T> {\n  if (!tree) {\n    return\n  }\n  if (tree.left) {\n    const iter = iterTree(tree.left, getVal)[Symbol.iterator]()\n    for (let item = iter.next(); !item.done; item = iter.next()) {\n      yield item.value\n    }\n  }\n  yield getVal(tree.value)\n  if (tree.right) {\n    const iter = iterTree(tree.right, getVal)[Symbol.iterator]()\n    for (let item = iter.next(); !item.done; item = iter.next()) {\n      yield item.value\n    }\n  }\n}\n\nexport default class ImmuMap<K, V> implements ReadonlyMap<K, V>, IImmutableSetable<K, V, ImmuMap<K, V>> {\n  get size() {\n    return this._size\n  }\n  private _size: number\n  private _tree: Tree<K, V>\n  private _hash: Hash\n\n  constructor(entries?: ReadonlyArray<[K, V]> | Iterable<[K, V]>, hash: Hash = defaultHash) {\n    this._tree = null\n    this._size = 0\n    this._hash = hash\n    if (entries) {\n      iter(entries, ([k, v]) => {\n        const [status, tree] = add(k, v, this._tree, hash)\n        this._tree = tree\n        if (status === AddStatus.added) {\n          this._size++\n        }\n      })\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n  forEach(callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void, thisArg?: any) {\n    iter(this.entries(), ([key, value]) =>\n      callbackfn.call(thisArg, value, key, this))\n  }\n  get(key: K) {\n    return get(key, this._tree, this._hash)\n  }\n  has(key: K) {\n    return mem(key, this._tree, this._hash)\n  }\n  clear(): ImmuMap<K, V> {\n    return new ImmuMap()\n  }\n  set(key: K, value: V): ImmuMap<K, V> {\n    const [status, tree] = add(key, value, this._tree, this._hash)\n    if (status !== AddStatus.none) {\n      const map = new ImmuMap<K, V>()\n      map._tree = tree\n      map._size = this._size\n      if (status === AddStatus.added) {\n        map._size++\n      }\n      return map\n    } else {\n      return this\n    }\n  }\n  delete(key: K): ImmuMap<K, V> {\n    const [removed, tree] = remove(key, this._tree, this._hash)\n    if (removed) {\n      const map = new ImmuMap<K, V>()\n      map._tree = tree\n      map._size = this._size - 1\n      return map\n    } else {\n      return this\n    }\n  }\n  keys() {\n    return iterTree(this._tree, v => v[0])\n  }\n  values() {\n    return iterTree(this._tree, v => v[1])\n  }\n  entries() {\n    return iterTree(this._tree, v => v)\n  }\n  toJSON(): { [ key: string ]: V } {\n    const obj = {} as { [ key: string ]: V }\n    iter(this.entries(), ([k, v]) => {\n      if (typeof k !== 'string' && typeof k !== 'number') {\n        error('map.toJSON failed, key: ', k, 'value:', v)\n        throw new TypeError(`map.toJSON requires map's key to be number or string, but got ${k}`)\n      }\n      obj[String(k)] = v\n    })\n    return obj\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/map.ts","import ImmuList from './list'\nimport ImmuMap from './map'\nimport ImmuSet from './set'\n\nexport { ImmuList, ImmuMap, ImmuSet }\nexport default { ImmuList, ImmuMap, ImmuSet }\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/index.ts","import { iterMap, iter } from './utils'\nimport { IImmutableSetable } from '../types'\nimport * as List from '@funkia/list'\n\nfunction * iteri(len: number): IterableIterator<number> {\n  for (let i = 0; i < len; i++) {\n    yield i\n  }\n}\n\nexport { List }\n\nexport default class ImmuList<T> implements IImmutableSetable<number, T, ImmuList<T>> {\n  get length() {\n    return this._list.length\n  }\n  private _list: List.List<T>\n\n  constructor(values?: T[]) {\n    if (values) {\n      this._list = List.fromArray(values)\n    } else {\n      this._list = List.empty()\n    }\n  }\n  toString(): string {\n    return 'ImmuList [' + List.toArray(this._list).toString() + ']'\n  }\n  toLocaleString(): string {\n    return 'ImmuList [' + List.toArray(this._list).toLocaleString() + ']'\n  }\n  get(i: number) {\n    return List.nth(i, this._list)\n  }\n  set(i: number, val: T): ImmuList<T> {\n    let list = this._list\n    if (i < 0 || i >= list.length) {\n      console.error(`index out of range (0, ${this._list.length}), this would silent ignored`)\n    }\n    list = List.update(i, val, this._list)\n    return this._new(list)\n  }\n  remove(from: number, amount: number = 1): ImmuList<T> {\n    const list = List.remove(from, amount, this._list)\n    return this._new(list)\n  }\n  includes(item: T) {\n    return List.includes(item, this._list)\n  }\n  append(item: T) {\n    return this._new(List.append(item, this._list))\n  }\n  prepend(item: T) {\n    return this._new(List.prepend(item, this._list))\n  }\n  first() {\n    return List.first(this._list)\n  }\n  last() {\n    return List.last(this._list)\n  }\n  tail(): ImmuList<T> {\n    return this._new(List.tail(this._list))\n  }\n  edit(cb: (list: List.List<T>, ListModule: typeof List) => List.List<T>): ImmuList<T> {\n    return this._new(cb(this._list, List))\n  }\n  editWithAny<U>(cb: (list: List.List<T>, ListModule: typeof List) => U): U {\n    return cb(this._list, List)\n  }\n  toArray() {\n    return List.toArray(this._list)\n  }\n  toJSON() {\n    return this.toArray()\n  }\n  concat(...items: (ImmuList<T> | Array<T> | T)[]): ImmuList<T> {\n    let list = this._list\n    iter(items, item => {\n      if (item instanceof ImmuList) {\n        list = List.concat(list, item._list)\n      } else if (item instanceof Array) {\n        list = item.reduce((l, i) => List.append(i, l), list)\n      } else {\n        list = List.append(item, list)\n      }\n    })\n    if (list.length > this._list.length) {\n      return this._new(list)\n    }\n    return this\n  }\n  join(separator?: string | undefined): string {\n    let sep = separator || ','\n    return List.join(sep, this._list as any)\n  }\n  slice(start?: number | undefined, end?: number | undefined) {\n    const newList = List.slice(start || 0, end || this._list.length, this._list)\n    if (newList.length !== this._list.length) {\n      return this._new(newList)\n    }\n    return this\n  }\n  indexOf(searchElement: T, fromIndex?: number | undefined): number {\n    let list = this._list\n    if (fromIndex) {\n      list = List.slice(fromIndex, this._list.length, list)\n    }\n    return List.indexOf(searchElement, list)\n  }\n  every(callbackfn: (value: T, index: number, array: this) => boolean, thisArg?: any): boolean {\n    let i = 0\n    return List.every(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, this._list)\n  }\n  some(callbackfn: (value: T, index: number, array: this) => boolean, thisArg?: any): boolean {\n    let i = 0\n    return List.some(v => {\n      return callbackfn.call(thisArg, v, i++, this)\n    }, this._list)\n  }\n  forEach(callbackfn: (value: T, index: number, array: this) => void, thisArg?: any): void {\n    let i = 0\n    List.foldl(\n      (_, v) => (callbackfn.call(thisArg, v, i++, this), undefined),\n      undefined,\n      this._list,\n    )\n  }\n  map<U>(callbackfn: (value: T, index: number, array: this) => U, thisArg?: any): ImmuList<U> {\n    let i = 0\n    const list = List.map(\n      v => callbackfn.call(thisArg, v, i++, this),\n      this._list,\n    )\n    return this._new(list)\n  }\n  filter(callbackfn: (value: T, index: number, array: this) => boolean, thisArg?: any): ImmuList<T> {\n    let i = 0\n    const list = List.filter(\n      v => callbackfn.call(thisArg, v, i++, this),\n      this._list,\n    )\n    if (list.length !== this._list.length) {\n      return this._new(list)\n    }\n    return this\n  }\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: this) => U, initialValue: U, thisArg?: any): U {\n    let i = 0\n    return List.foldl(\n      (acc, v) => callbackfn.call(thisArg, acc, v, i++, this),\n      initialValue,\n      this._list,\n    )\n  }\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: this) => U, initialValue: U, thisArg?: any): U {\n    let i = 0\n    return List.foldr(\n      (v, acc) => callbackfn.call(thisArg, acc, v, i++, this),\n      initialValue,\n      this._list,\n    )\n  }\n  [Symbol.iterator](): IterableIterator<T> {\n    return iterMap(this._list, v => v)\n  }\n  entries(): IterableIterator<[number, T]> {\n    let i = 0\n    return iterMap(this._list, v => [i++, v] as [number, T])\n  }\n  keys(): IterableIterator<number> {\n    return iteri(this._list.length)\n  }\n  values(): IterableIterator<T> {\n    return iterMap(this._list, v => v)\n  }\n  find(predicate: (value: T, index: number, obj: this) => boolean, thisArg?: any): T | undefined {\n    let i = 0\n    return List.find(\n      v => predicate.call(thisArg, v, i++, this),\n      this._list,\n    )\n  }\n  findIndex(predicate: (value: T, index: number, obj: this) => boolean, thisArg?: any): number {\n    let i = 0\n    return List.findIndex(\n      v => predicate.call(thisArg, v, i++, this),\n      this._list,\n    )\n  }\n  private _new<T>(list: List.List<T>) {\n    const newImmuList = new ImmuList<T>()\n    newImmuList._list = list\n    return newImmuList\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/list.ts",null,"import ImmuMap from './map'\nimport { defaultHash, Hash, iter, iterMap } from './utils'\n\nexport { defaultHash, Hash }\n\nexport default class ImmuSet<T> implements ReadonlySet<T> {\n  get size() {\n    return this._map.size\n  }\n  private _map: ImmuMap<T, T>\n  constructor(values?: ReadonlyArray<T> | Iterable<T>, hash: Hash = defaultHash) {\n    if (values) {\n      this._map = new ImmuMap(iterMap(values, v => [v, v] as [T, T]), hash)\n    } else {\n      this._map = new ImmuMap([], hash)\n    }\n  }\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._map.keys()\n  }\n  add(value: T): ImmuSet<T> {\n    const map = this._map.set(value, value)\n    if (map.size > this._map.size) {\n      const newSet = new ImmuSet<T>()\n      newSet._map = map\n      return newSet\n    }\n    return this\n  }\n  clear(): ImmuSet<T> {\n    return new ImmuSet()\n  }\n  delete(value: T): ImmuSet<T> {\n    const map = this._map.delete(value)\n    if (map.size < this._map.size) {\n      const newSet = new ImmuSet<T>()\n      newSet._map = map\n      return newSet\n    }\n    return this\n  }\n  entries(): IterableIterator<[T, T]> {\n    return this._map.entries()\n  }\n  keys(): IterableIterator<T> {\n    return this._map.keys()\n  }\n  values(): IterableIterator<T> {\n    return this._map.values()\n  }\n  toArray(): T[] {\n    const arr = [] as T[]\n    iter(this.keys(), item => arr.push(item))\n    return arr\n  }\n  toJSON(): T[] {\n    return this.toArray()\n  }\n  forEach(callbackfn: (value: T, value2: T, set: ReadonlySet<T>) => void, thisArg?: any): void {\n    this._map.forEach((v1, v2, _) => callbackfn(v1, v2, this), thisArg)\n  }\n  has(value: T): boolean {\n    return this._map.has(value)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collections/set.ts"],"sourceRoot":""}